module string

//
// Stack String, Static, No Free.
// Just a pointer to the constant string.
//
pub wrapper layout String {
    data: void*;
}

//
// Public API
//
pub fn String::size(this: String) -> u32 {
    if this.data == nullptr { return 0u32; }
    return this.data.ptrcast(u32).*;
}

pub fn String::clone(this: String) -> String {
    if this.data == nullptr { return empty(); }
    return String(this.data);
}

// returns false if index is out of bounds
pub fn String::get(this: String, index: u32) -> (bool, u8) {
    if this.data == nullptr { return {false, 0u8}; }
    if this.size() <= index {
        return {false, 0u8};
    }

    return {true, this.data.offset(index+4u32).ptrcast(u8).*};
}

pub fn String::unsafe_get(this: String, index: u32) -> u8 {
    return this.data.offset(index+4u32).ptrcast(u8).*;
}

pub fn String::equals(this: String, other: String) -> bool {
    let thisSize := this.size();
    if thisSize != other.size() {
        return false;
    }

    let mut index := 0u32;
    while true {
        let (cnd1:, ch1:) = this.get(index);
        let (cnd2:, ch2:) = other.get(index);

        if !(cnd1 && cnd2) { return false; }
        if ch1 != ch2 { return false; }

        index = index + 1u32;
        if index == thisSize {
            break;
        }
    }

    return true;
}

pub fn String::isEmpty(this: String) -> bool {
    if this.data == nullptr { return true; }
    return this.size() == 0u32;
}

pub fn String::isNull(this: String) -> bool {
    return this.data == nullptr;
}

pub fn empty() -> String {
    return "";
}
