module string

include "lib/jasl/memory.jasl"
include "lib/jasl/io.jasl"

// TODO: Improve this.

pub wrapper layout String {
    data: ptr;
}

pub fn String::size() -> u32 {
    asm { mov &ebx rda %ui mov 4 &bl ret }
    return 0u32;
}

pub fn String::data() -> i8* {
    return this.data.offset(4).ptrcast(i8);
}

pub fn String::delete() -> void {
    return this.data.memory::free(this.size()+4u32);
}

pub fn String::clone() -> String {
    let size: u32 = this.size();
    let new: ptr = memory::malloc(size+4u32);
    this.data.memory::memcpy(new, size);
    return String(new);
}

// returns false if index is out of bounds
pub fn String::get(index: u32) -> (bool, u8) {
    if this.size() <= index {
        return {false, 0u8};
    }

    asm { add %ui mov &ebx }
    let mut char: u8;
    asm { dcr %ui &sp 1 rda %ub }
    return {true, char};
}

pub fn String::equals(other: String) -> bool {
    let thisSize: u32 = this.size();
    if thisSize != other.size() {
        return false;
    }

    let mut condition: bool = true;
    let mut index: u32 = 0u32;
    while condition {
        if this.get(index) != other.get(index) {
            return false;
        }

        index = index + 1u32;
        if index == thisSize {
            condition = false;
        }
    }

    return false;
}

// returns false if out of bounds occurs
pub fn String::substring(start: u32, n: u32) -> (bool, String) {
    if start + n > this.size() {
        return {false, String(nullptr)};
    }

    let substr: ptr = memory::malloc(n+4u32);
    this.data
        .offset(start)
        .memory::memcpy(substr, n);
    return {true, String(substr)};
}

pub fn String::isEmpty() -> bool {
    return this.size() == 0u32;
}

pub fn empty() -> String {
    let new: ptr = memory::malloc(4u32);
    asm { mov &ebx stc %ui 0 ldc %ui }
    return String(new);
}
