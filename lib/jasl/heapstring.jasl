module hstring

include "lib/jasl/string"
include "lib/jasl/memory"
include "lib/jasl/io"

pub layout HeapString {
    mut data: void*;
    mut totalSize: u32;
    pub allocator: allocator::Allocator;
}

pub fn HeapString::new(str: string::String, alloc: allocator::Allocator) -> HeapString {
    let strSize := str.string::size();
    let totalSize := strSize+36u32;
    let memory := memory::malloc(totalSize, alloc);

    if memory == nullptr { return HeapString(nullptr, 0u32, alloc); }

    let mut cdata: void*;
    asm {
        pop %ui
        rdl %ui 0
    }

    if memory::memcpy(cdata, memory, strSize+4u32) {
        return HeapString(memory, totalSize, alloc);
    }

    memory::free(memory, totalSize, alloc);
    return HeapString(nullptr, 0u32, alloc);
}

pub fn HeapString::capacity(this: HeapString) -> u32 {
    return this.totalSize - 4u32;
}

pub fn HeapString::size(this: HeapString) -> u32 {
    if this.data == nullptr { return 0u32; }
    return this.data.ptrcast(u32).deref();
}

pub fn HeapString::data(this: HeapString) -> i8* {
    if this.data == nullptr { return nullptr; }
    return this.data.offset(4).ptrcast(i8);
}

pub fn HeapString::free(this: HeapString) -> bool {
    if this.data == nullptr { return false; }
    return memory::free(this.data, this.totalSize, this.allocator);
}

pub fn HeapString::view(this: HeapString) -> string::String {
    if this.data == nullptr { return string::empty(); }
    return string::String(this.data);
}

pub fn HeapString::clone(this: HeapString, alloc: allocator::Allocator) -> HeapString {
    return new(this.view(), alloc);
}

