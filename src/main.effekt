// The Jasl language will be compiled to JASM IL then to JASM Bytecode
// to be executed in CSR.
// JASM supports (u)int32, (u)int8 and 32-bit floating point numbers
// as well as 32-bit pointers. So these are all Jasl will have, well bools are present
// too but they're uint8 under the hood.
//
//
// Jasl will have objects but won't have inheritance since I don't want to deal
// with vtables. No interfaces either, at least for now.

import process
import args
import context/context
import lexer/lexer
import parser/parser
import native/native
import map

def printHelp(): Unit = {
    println("The JASL Compiler")
    println("\tVersion: __VERSION__")
    println("\nUsage:\n\tjasl [flags] <file>\n\n\tFlags:\n\t\t-h : Prints this help message.")
}

def main() = {
    // 1- Parse command line
    // 2- Lex input file(s)
    // 3- Prepass file(s)
    // 4- Parse lexed file(s)
    // 5- Generate JASM IL
    // 6- Call AssembleIL(filePath)
    // FIN
    //
    // Write build files to ./.build/

    val args: List[String] = llvm::commandLineArgs()
    val argc: Int = llvm::argCount()

    if (argc <= 1 || args.contains("-h"){strEquals}) {
        printHelp()
    } else {
        with internalErrorHandler;
        try {
            with compilerContextHandler;
            with on[OutOfBounds].panic;

            do setWorkingFile(llvm::argument(1))

            val tokenized: List[Token] = lexer::lex()
            parser::prepass(tokenized)

__DEBUG_START__
            feed[ModuleInfo] { () => do emitModules() } { case ModuleInfo(name, vars, fns, lays) => {
                with parser_report;
                with tokenHandler(tokenized);
                println("\nModule Info: "++name)

                println("\tVariables:")
                feed[VariableSignature] { vars.eachValue } { v => println("\t\t"++v.show()) }

                println("\tFunctions:")
                feed[FunctionSignature] { fns.eachValue } { v => println("\t\t"++v.show()) }

                println("\tLayouts:")
                feed[LayoutSignature] { lays.eachValue } { v => println("\t\t"++v.show()) }
            }} 
__DEBUG_END__

            feed[(String, LexerContext)]{ () => do emitLexerOutput() } { case (filename, context) => {
                do setWorkingFile(filename)
                do setWorkingModule(context.name)
__DEBUG_START__
                println("\nParse called for "++do getWorkingFile()++" module "++do getWorkingModule())
__DEBUG_END__
                do registerAST(parser::parse(context.tokens))
            }}

            // val ast: AST = parser::parse(tokenized)
            // val asmfile: String = generator::generate_il(AST)
            // AssembleIL(asmfile)
        } with StopCompiler {
            println("Compiler exited without any errors.")
        }
    }
}

