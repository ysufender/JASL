// The Jasl language will be compiled to JASM IL then to JASM Bytecode
// to be executed in CSR.
// JASM supports (u)int32, (u)int8 and 32-bit floating point numbers
// as well as 32-bit pointers. So these are all Jasl will have, well bools are present
// too but they're uint8 under the hood.
//
//
// Jasl will have objects but won't have inheritance since I don't want to deal
// with vtables. No interfaces either, at least for now.

import native/native
import context/context
import lexer/lexer
import parser/parser
import ilgen/ilgen

import args
import process
import map

def printHelp(): Unit = {
    println("The JASL Compiler")
    println("\tVersion: __VERSION__")
    println("\tUsage:\n\tjasl <input_file> [flags]")
    println("\t\tFlags:")
    println("\t\t--help                  : print this help message\n")
    println("\t\t--typecheck             : do not compile or assemble, typecheck only")
    println("\t\t--compile               : do not assemble, generate IL only\n")
    println("\t\t--static                : build a static library")
    println("\t\t--dynamic               : build a dynamic library\n")
    println("\t\t--release [jit = false] : build in release mode, with optional jit support. defaults to false.\n")
    println("\t\t--output <file_name>    : set output file name")
    println("\t\t--working <file_name>   : set working directory\n")
    println("\t\t--check-nullptr         : enable nullptr check on every pointer operation\n")
    println("\t\t--include               : include the given directory as a search path\n")
    // println("\t\t--run                   : run the given file after compiling")
}

def parseCommandLine(): String / CompilerSettingsRegister = {
    var args: List[String] = llvm::commandLineArgs()
    val argc: Int = llvm::argCount()
    var file = "";

    if (argc <= 1) {
        printHelp()
        exit(0)
    }

    def shift(): String = args match {
        case Cons(head, rest) => {
            args = rest
            head
        }
        case Nil() => {
            println("Unexpected end of arguments at command line. Check 'jasl --help' to see the correct use.")
            exit(1)
        }
    }

    while (not(args.isEmpty)) shift() match {
        case "--help" => {
            printHelp()
            exit(0)
        }
        case "--typecheck" => do typeCheckOnly()
        case "--compile" => do compileOnly()
        case "--static" => do buildStatic()
        case "--dynamic" => do buildDynamic()
        case "--release" => shift() match {
            case "true" => do releaseBuild(true)
            case "false" => do releaseBuild(false)
            case someOther => 
                if (someOther.startsWith("--")) {
                    args = Cons(someOther, args)
                } else {
                    println("Expected a flag or boolean here, got '"++someOther++"' instead.")
                    exit(1)
                }
        }
        case "--output" => do setOutputFile(shift())
        case "--working" => do setWorkingDir(shift())
        case "--nullptr-check" => do setFlag("nullptr-check")
        case "--include" => do addIncludePath(shift())
        // case "--run" => do setFlag("run")
        case someOther => 
            if (file.length == 0)
                file = someOther
            else {
                println("Unknown command line argument '"++someOther++"'. See 'jasl --help' for correct use.")
                exit(0)
            }
    }

    if (file.length == 0) {
        println("No input files were given.")
        exit(0)
    }

    file
}

def main() = {
    with ignoreStop;
    with settingsHandler;
    // 1- Parse command line
    // 2- Lex input file(s)
    // 3- Prepass file(s)
    // 4- Parse lexed file(s)
    // 5- Generate JASM IL
    // 6- Call AssembleIL(filePath)
    // FIN
    //
    // Write build files to ./.build/

    with internalErrorHandler;
    with compilerContextHandler;
    with handleGlobals;
    with on[OutOfBounds].panic;

    do setWorkingFile(getFile(parseCommandLine()))

    val tokenized: List[Token] = lexer::lex()
    val topLevel: ParserContext = emptyParserContext()
    parser::prepass(tokenized, topLevel)

    // check for main module and entry point.
    // every project must include a main module that has a main function
    // with a signature fn () -> void
    // entry point must be private.
    if (not(do checkEntryPoint())) {
        println("[ERROR] Couldn't find entry point accross the project.")
        println("        The entry point must reside in module 'main', must not be public,")
        println("        and must have the signature fn () -> void")
        println("\n        Example:")
        println("                module main")
        println("                fn main() -> void {")
        println("                ")
        println("                }")
        exit(1)
    }

__DEBUG_START__
    feed[ModuleInfo] { () => do emitModules() } { case ModuleInfo(name, vars, fns, lays) => {
        with parser_report;
        with tokenHandler(tokenized);
        with contextHandler(emptyParserContext())
        println("\nModule Info: "++name)

        do setWorkingModule(name)

        println("\tVariables:")
        feed[VariableSignature] { vars.eachValue } { v => println("\t\t"++v.show()) }

        println("\tFunctions:")
        feed[FunctionSignature] { fns.eachValue } { v => println("\t\t"++v.show()) }

        println("\tLayouts:")
        feed[LayoutSignature] { lays.eachValue } { v => println("\t\t"++v.show()) }
    }} 
__DEBUG_END__

    feed[(String, LexerContext)]{ () => do emitLexerOutput() } { case (filename, context) => {
        do setWorkingFile(filename)
        do setWorkingModule(context.name)
        debugPrint("Parse called for "++filename++" module "++do getWorkingModule())
        do registerAST(parser::parse(context.tokens, topLevel))
    }}

    if (do getPipelineMode() is TypeCheckOnly())
    {
        println("Finished typechecking.")
        exit(0)
    }

    // register global variable ASTs, the AST register is LIFO
    // let the ilgen handle this
    /*(do getGlobalVarASTs()).foreach{ ast => {
        debugPrint("Registering global variables for module "++ast.moduleName++".")
        do registerAST(ast)
    }}*/

    ilgen::gen(do getOutFile()++".jasm", topLevel)

    if (do getPipelineMode() is ILOnly()) {
        println("Finished generating IL.")
        exit(0)
    }

    if (AssembleIL(do getOutFile()++".jasm")) {
        println("Finished compiling.")
/*        if (do getFlag("run")) {
            val exitCode = RunByteCode(do getOutFile())
            if (exitCode != 0) {
                println("An error occured during runtime. Exit Code: "++exitCode.show)
            }
        }
*/
    } else {
        println("Compilation terminated.")
    }
}

