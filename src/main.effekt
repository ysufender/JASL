// The Jasl language will be compiled to JASM IL then to JASM Bytecode
// to be executed in CSR.
// JASM supports (u)int32, (u)int8 and 32-bit floating point numbers
// as well as 32-bit pointers. So these are all Jasl will have, well bools are present
// too but they're uint8 under the hood.
//
//
// Jasl will have objects but won't have inheritance since I don't want to deal
// with vtables. No interfaces either, at least for now.

import process
import args
import context/context
import lexer/lexer
import parser/parser
import native/native
import map

def printHelp(): Unit = {
    println("The JASL Compiler")
    println("\tVersion: __VERSION__")
    println("\nUsage:\n\tjasl [flags] <file>\n\n\tFlags:\n\t\t-h : Prints this help message.")
}

def main() = {
    // 1- Parse command line
    // 2- Lex input file(s)
    // 3- Prepass file(s)
    // 4- Parse lexed file(s)
    // 5- Generate JASM IL
    // 6- Call AssembleIL(filePath)
    // FIN
    //
    // Write build files to ./.build/

    val args: List[String] = llvm::commandLineArgs()
    val argc: Int = llvm::argCount()

    if (argc <= 1 || args.contains("-h"){strEquals}) {
        printHelp()
    } else {
        with internalErrorHandler;
        try {
            with compilerContextHandler;
            with on[OutOfBounds].panic;

            do setWorkingFile(llvm::argument(1))

            val tokenized: List[Token] = lexer::lex()
            parser::prepass(tokenized)

            // check for main module and entry point.
            // every project must include a main module that has a main function
            // with a signature fn () -> i32
            // entry point must be private.
            if (not(do checkEntryPoint())) {
                println("[ERROR] Couldn't find entry point accross the project.")
                println("        The entry point must reside in module 'main', must not be public,")
                println("        and must have the signature fn () -> i32")
                println("\n        Example:")
                println("                module main")
                println("                fn main() -> i32 {")
                println("                    return 0;")
                println("                }")
                exit(1)
            }
__DEBUG_START__
            feed[ModuleInfo] { () => do emitModules() } { case ModuleInfo(name, vars, fns, lays) => {
                with parser_report;
                with tokenHandler(tokenized);
                with contextHandler(emptyParserContext())
                println("\nModule Info: "++name)

                println("\tVariables:")
                feed[VariableSignature] { vars.eachValue } { v => println("\t\t"++v.show()) }

                println("\tFunctions:")
                feed[FunctionSignature] { fns.eachValue } { v => println("\t\t"++v.show()) }

                println("\tLayouts:")
                feed[LayoutSignature] { lays.eachValue } { v => println("\t\t"++v.show()) }
            }} 
__DEBUG_END__

            feed[(String, LexerContext)]{ () => do emitLexerOutput() } { case (filename, context) => {
                do setWorkingFile(filename)
                do setWorkingModule(context.name)
                debugPrint("Parse called for "++do getWorkingFile()++" module "++do getWorkingModule())
                do registerAST(parser::parse(context.tokens))
            }}

            // val ast: AST = parser::parse(tokenized)
            // val asmfile: String = generator::generate_il(AST)
            // AssembleIL(asmfile)
        } with StopCompiler {
            println("Compiler exited without any errors.")
        }
    }
}

