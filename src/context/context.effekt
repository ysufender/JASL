module context

import process
import io/filesystem
import io/error
import io
import map

import native/native

val helpLines: List[String] = [
    "Here",
    "No need to thank me",
    "Right here buddy",
    "It's here lad",
    "I spotted it, just for you",
    "I FOUND HIM BOSS",
    "You seriously missed this?",
    "Come on, it's here",
    "You should be a bit more careful with your code",
    "Hm. Here",
    "|____ <- There",
    "I'm running out of ideas for error indicator messages",
    "You can't hate yourself, not yet"
]

def getHelpLine(): String = try { 
        val rand: Int = random_range(0, helpLines.size() - 1)
        helpLines.get(rand)
    } with Exception[OutOfBounds] {
        def raise(_, _) = "<unknown>"
    }

effect InternalError(msg: String, file: String, line: String): Nothing

def internalErrorHandler[T]{ prog: () => T / InternalError }: T = {
    try { prog() }
    with InternalError { (msg, file, line) => {
        println("[INTERNAL ERROR "++file++":"++line++"] The program ran into an unexpected internal error. Please report this issue to the author.")
        println("        Internal Message: "++msg)
        exit(1)
    }}
}

def unpackOrCrash[T](optional: Option[T]): T / InternalError = optional match {
    case Some(value) => value
    case None() => do InternalError("Expected a defined option.", __FILE__, __LINE__)
}

def compare[T](lhs: List[T], rhs: List[T]) { eq: (T, T) => Bool }: Bool = {
    if (lhs is Cons(head1, rest1) and rhs is Cons(head2, rest2)) {
        if (head1.eq(head2)) compare(rest1, rest2) { eq }
        else false
    }
    else if (lhs.isEmpty && rhs.isEmpty) { true }
    else false
}

type Type {
    Bool()
    UInt()
    Int()
    Float()
    UByte()
    Byte()
    Pointer(ptrType: Type)
    Void()
    FunctionPointer(arguments: List[Type], returns: List[Type])
    Custom(name: QualifiedName)
    // MAYBE: add type Runtime() for runtime sized types.
    // because the bytecode can return differing sizes from functions and
    // thanks to bl register the caller can know the return size. Also
    // the callee can know the parameter size like that too so we can do
    // insane unsafe calls (long as it's 256 bytes max) and returns.
}

record FunctionSignature(
    name: String,
    public: Bool,
    comptime: Bool,
    ofType: Option[Type],
    arguments: List[VariableSignature],
    returns: List[Type]
)

record LayoutSignature(
    name: String,
    public: Bool,
    wrapper: Bool,
    fields: List[VariableSignature]
)

record VariableSignature(
    name: String,
    public: Bool,
    mutable: Bool,
    comptime: Bool,
    global: Bool,
    stackIndex: Int,
    varType: Type
)

type PreprocessorKeywordType {
    Module()
    Include()
}

type KeywordType {
    Preprocessor(pWord: PreprocessorKeywordType)
    Wrapper()
    Layout()
    Fn()
    Pub()
    Return()
    Let()
    Void()
    While()
    Extern()
    If()
    Else()
    Mut()
}

type SymbolType {
    LParen()
    RParen()
    LBrace()
    RBrace()
    Comma()
    Colon()
    Semicolon()
    DotSym()
    DoubleColon()
    Arrow()
    Assign()
    Asterix()
    LessSym()
    GreatSym()
    LessEq()
    GreatEq()
    Equals()
    NotEq()
    NotSym()
    Minus()
    Plus()
    Divide()
    AndSym()
    OrSym()
}

type DataType {
    BoolT(value: Option[Bool]) // for 'true' and 'false' keywords.
    StringT()
    UIntT()
    IntT()
    FloatT()
    UByteT()
    ByteT()
    PointerT(ptrType: DataType)
    VoidT()
    CustomT(name: String)
}

type TokenType {
    LiteralT(valueType: DataType)
    IdentifierT()
    Keyword(keywordType: KeywordType)
    Symbol(symbolType: SymbolType)
    TypeNameT(typeType: DataType)
    EOF()
}

record Position(line: Int, col: Int, index: Int)
record Token(tokenType: TokenType, text: String, position: Position)

record ParserContext(
    parent: Option[ParserContext],
    stackIndex: Int, // for in-function blocks to get the local variables easily.
    variables: Map[String, VariableSignature]
    // these are already in CompilerContext
    // functions: Map[String, FunctionSignature],
    // layouts: Map[String, LayoutSignature]
)

type Literal {
    Bool(value: Bool)
    String(value: String)
    UInt(value: Int)
    Int(value: Int)
    Float(value: Double)
    UByte(value: Int)
    Byte(value: Int)
    Nullptr()
}

type BinaryOp {
    Addition(lhs: Expression, rhs: Expression)
    Subtraction(lhs: Expression, rhs: Expression)
    Division(lhs: Expression, rhs: Expression)
    Multiplication(lhs: Expression, rhs: Expression)
    Equality(lhs: Expression, rhs: Expression)
    Inequality(lhs: Expression, rhs: Expression)
    Great(lhs: Expression, rhs: Expression)
    Lesser(lhs: Expression, rhs: Expression)
    GreaterEqual(lhs: Expression, rhs: Expression)
    LesserEqual(lhs: Expression, rhs: Expression)
    And(lhs: Expression, rhs: Expression)
    Or(lhs: Expression, rhs: Expression)
}

type UnaryOp {
    Negation(rhs: Expression)
    Not(rhs: Expression)
}

type Expression {
    Initialization(name: QualifiedName, initializers: List[Expression])
    Identifier(name: QualifiedName)
    Binary(binOp: BinaryOp)
    Unary(unOp: UnaryOp)
    Grouping(inside: Expression)
    Literal(value: Literal)
    Dot(lhs: Expression, member: String)
    Scoping(lhs: QualifiedName, member: String)
    Call(fn: Expression, args: List[Expression])
    Block(inside: List[Statement], scope: ParserContext)
}

type Statement {
    ExpressionStatement(expr: Expression, pos: Position)
    VariableDefinition(signature: VariableSignature, initializer: Option[Expression], pos: Position)
    Conditional(condition: Expression, body: Statement, scope: ParserContext, fallback: Option[Statement], pos: Position)
    WhileStmt(condition: Expression, body: Statement, scope: ParserContext, pos: Position)
    FnDefinition(signature: FunctionSignature, body: List[Statement], scope: ParserContext)
    // LayoutDeclaration(signature: LayoutSignature, pos: Position)
    ReturnStmt(returns: List[Expression], pos: Position)
    Assignment(lhs: Expression, rhs: Expression, pos: Position)
}

record LexerContext(name: String, tokens: List[Token])
record AST(moduleName: String, body: List[Statement])

record QualifiedName(mod: Option[String], name: String)
record ModuleInfo(name: String, variables: Map[String, VariableSignature], functions: Map[String, FunctionSignature], layouts: Map[String, LayoutSignature])

effect StopCompiler(): Nothing

interface CompilerContextRequest {
    def setWorkingFile(file: String): Unit // sets the current working file to return fi file name request comes.
    def getWorkingFile(): String // file name request
    def setWorkingModule(mod: String): Unit // set working module name to mangle function names.
    def getWorkingModule(): String // module name request.
    def checkDependency(file: String): Bool // import "file", if it's already processed returns true, if not returns false
    def updateModule(variables: Map[String, VariableSignature], functions: Map[String, FunctionSignature], layout: Map[String, LayoutSignature]): Unit / InternalError
    // def getWorkingModuleInfo(): ModuleInfo
    def increaseGlobalStackIndex(amount: Int): Unit
    def getGlobalStackIndex(): Int
    def registerLexerOutput(output: List[Token]): Unit
    def emitLexerOutput(): Unit / emit[(String, LexerContext)]
    def getLayoutSignature(name: QualifiedName): Option[LayoutSignature]
    def getVariableSignature(name: QualifiedName): Option[VariableSignature]
    def getFunctionSignature(name: QualifiedName): Option[FunctionSignature]
    def checkEntryPoint(): Bool
__DEBUG_START__
    def emitModules(): Unit / emit[ModuleInfo]
__DEBUG_END__
    def registerAST(ast: AST): Unit
    def emitAST(): AST / StopCompiler
}

def infixEq(l: Type, r: Type): Bool / CompilerContextRequest = (l, r) match {
    case (Type::Bool(), Type::Bool()) => true
    case (Type::UInt(), Type::UInt()) => true
    case (Type::Int(), Type::Int()) => true
    case (Type::Float(), Type::Float()) => true
    case (Type::UByte(), Type::UByte()) => true
    case (Type::Byte(), Type::Byte()) => true
    case (Type::Pointer(p1), Type::Pointer(p2)) => (p1 == p2)
    case (Type::Void(), Type::Void()) => true
    case (Type::FunctionPointer(a1, r1), Type::FunctionPointer(a2, r2)) => (a1.compare(a2){(a, b) => a == b} && r1.compare(r2){(a, b) => a == b})
    case (Type::Custom(n1), Type::Custom(n2)) => {
        val q1 = QualifiedName(n1.mod match {
            case Some(_) => n1.mod
            case None() => Some(do getWorkingModule())
        }, n1.name)
        val q2 = QualifiedName(n2.mod match {
            case Some(_) => n2.mod
            case None() => Some(do getWorkingModule())
        }, n2.name)
        q1 == q2
    }
    case (_, _) => false
}

def infixEq(l: QualifiedName, r: QualifiedName): Bool = {
    val b1: Bool = l.mod match {
        case Some(m1) => r.mod match {
            case Some(m2) => m1 == m2
            case None() => false
        }
        case None() => r.mod match {
            case Some(_) => false
            case None() => true
        }
    }
    b1 && (l.name == r.name)
}

def openRead(file: String): String / {CompilerContextRequest, InternalError} = {
    try { with filesystem; readFile(file) }
    with Exception[IOError] {
        def raise(_, _) = do InternalError("Couldn't open file at path '"++file++"'.", __FILE__, __LINE__)
    }
}

def feed[T] { stream: () => Unit / emit[T] } { prog: (T) => Unit / {CompilerContextRequest, InternalError} }: Unit / {CompilerContextRequest, InternalError} = {
    try { stream() }
    with emit[T] { v => {
        prog(v)
        resume(())
    }}
}

def unimplemented(file: String, line: String): Nothing / InternalError = {
    do InternalError("This segment of the project is still unimplemented. Please stay tuned.", file, line)
}

def unreachable(file: String, line: String): Nothing / InternalError = {
    do InternalError("This segment of the project is meant to be unreachable. Please contact the author to inform of this error.", file, line)
}

def combine[T](l1: List[T], l2: List[T]): List[T] = l1 match {
    case Cons(head, rest) => combine[T](rest, Cons(head, l2))
    case Nil() => l2
}

def show(n: QualifiedName): String = n.mod match {
    case Some(modname) => modname++"::"++n.name
    case None() => n.name
}

def toType(dt: DataType): Type = dt match {
    case BoolT(_) => Bool()
    case StringT() => Custom(QualifiedName(None(), "String"))
    case UIntT() => UInt()
    case IntT() => Int()
    case FloatT() => Float()
    case UByteT() => UByte()
    case ByteT() => Byte()
    case PointerT(ptrType) => Pointer(ptrType.toType())
    case VoidT() => Void()
    case CustomT(name) => Custom(QualifiedName(None(), name))
}

def toType(tt: TokenType): Type / InternalError = tt match {
    case TypeNameT(dt) => dt.toType()
    case _ => do InternalError("Can't turn a token type other than TypeNameT to Type", __FILE__, __LINE__)
}

def strEquals(l: String, r: String): Bool =
    l == r

def strOrder(l: String, r: String): Ordering = if (strEquals(l, r)) { Equal() } else { Less() }

// should be sure that option is defined
def unpack[T](option: Option[T]): T = option match {
    case Some(t) => t
    case None() => <> /*do InternalError("Unpack on empty option.", __FILE__, __LINE__)*/
}

effect DuplicateKey[T](key: T): Nothing
def combineMapNoDup[T, U](m1: Map[T, U], m2: Map[T, U]): Map[T, U] / DuplicateKey[T] = {
    var dupKey: Option[T] = None()
    if (m1.keys.any { k => { dupKey = Some(k); m2.contains(k) } })
        do DuplicateKey(dupKey.unpack())
    m1.union(m2)
}

def emptyModule(name: String): ModuleInfo = ModuleInfo(name, map::empty[String, VariableSignature](box strOrder), map::empty[String, FunctionSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))

def compilerContextHandler[T] { prog: () => T /  {CompilerContextRequest, InternalError} }: T / {InternalError, StopCompiler} = {
    var currentFile: String = ""
    var currentModule: String = ""
    var processedFiles: Map[String, LexerContext] = map::empty(box strOrder)
    var modules: Map[String, ModuleInfo] = map::empty(box strOrder)
    var asts: List[AST] = []
    var globalStackIndex: Int = 0

    try { prog() }
    with CompilerContextRequest {
        def setWorkingFile(file) = {
            currentFile = file
            if (not(processedFiles.contains(file)))
                processedFiles = processedFiles.put(file, LexerContext(currentModule, []))
            resume(())
        }
        def getWorkingFile() = resume(currentFile)
        def setWorkingModule(mod) = {
            currentModule = mod
            if (not(modules.contains(mod)))
                modules = modules.put(mod, emptyModule(mod))
            resume(())
        }
        def getWorkingModule() = resume(currentModule)
        def checkDependency(file) = resume(processedFiles.contains(file))
        def updateModule(variables, functions, layouts) = resume {
            if (modules.contains(currentModule)) try {
                // overwrites
                // modules = modules.put(currentModule, ModuleInfo(currentModule, variables, functions, layout))

                // appends to the existing module
                val oldInf = modules.get(currentModule).unpack()

                try {
                    val newInf = ModuleInfo(
                        currentModule,
                        oldInf.variables.combineMapNoDup(variables),
                        oldInf.functions.combineMapNoDup(functions),
                        oldInf.layouts.combineMapNoDup(layouts)
                    )

                    modules = modules.put(currentModule, newInf)
                } with DuplicateKey[String] { k => {
                    println("[PARSER ERROR] "++currentFile++" at ???: Multiple definitions of '"++k++"' in module '"++currentModule++"'.")
                    exit(1)
                }}
            } with DuplicateKey[String] { signature => {
                println("[PARSER ERROR] "++currentFile++" at "++"???:"++" Multiple definition of '"++currentModule++"::"++signature++"' in module '"++currentModule++"'.\n")
                exit(1)
            }} else {
                do InternalError("Call 'context::setWorkingModule' before calling 'context::updateModule'", __FILE__, __LINE__)
            }
        }
        /*def getWorkingModuleInfo(): ModuleInfo = resume(
            try { modules.get(currentModule).unpack() }
            with InternalError { (_, _, _) => { <> }}
        )*/
        def increaseGlobalStackIndex(amount) = {
            globalStackIndex = globalStackIndex + amount
            resume(())
        }
        def getGlobalStackIndex() = resume(globalStackIndex)
        def registerLexerOutput(output) = {
            processedFiles = processedFiles.put(currentFile, LexerContext(currentModule, output)) // overrides the value at name
            resume(())
        }
        def emitLexerOutput() = resume {
            processedFiles.each()
        }
        def getLayoutSignature(name) = resume(
            name.mod match {
                case None() => modules.get(currentModule).unpack().layouts.get(name.name)
                case Some(moduleinfo) => modules.get(moduleinfo).unpack().layouts.get(name.name) match {
                    case Some(layout) => if (not(layout.public) && (moduleinfo != currentModule)) { None() }
                                           else { Some(layout) }
                    case None() => None()
                }
            }
        )
        def getVariableSignature(name) = resume(
            name.mod match {
                case None() => modules.get(currentModule).unpack().variables.get(name.name)
                case Some(moduleinfo) => modules.get(moduleinfo).unpack().variables.get(name.name) match {
                    case Some(variable) => if (not(variable.public) && (moduleinfo != currentModule)) { None() }
                                           else { Some(variable) }
                    case None() => None()
                }
            }
        )
        def getFunctionSignature(name) = resume(
            name.mod match {
                case None() => modules.get(currentModule).unpack().functions.get(name.name)
                case Some(moduleinfo) => modules.get(moduleinfo).unpack().functions.get(name.name) match {
                    case Some(function) => if (not(function.public) && (moduleinfo != currentModule)) { None() }
                                           else { Some(function) }
                    case None() => None()
                }
            }
        )
        def checkEntryPoint() = resume(modules.get("main") match {
            case None() => false
            case Some(mod) => mod.functions.get("main") match {
                case None() => false
                case Some(fn) => fn.returns match {
                    case Cons(Type::Int(), Nil()) => not(fn.public) && fn.arguments.isEmpty
                    case _ => false
                }
            }
        })
__DEBUG_START__
        def emitModules() = resume {
            modules.eachValue()
        } 
__DEBUG_END__
        def registerAST(ast) = {
            asts = Cons(ast, asts)
            resume(())
        }
        def emitAST() = resume {
            asts match {
                case Cons(ast, rest) => {
                    asts = rest
                    ast
                }
                case Nil() => do StopCompiler()
            }
        }
    }
}
