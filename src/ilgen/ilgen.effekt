module ilgen

import parser/parser
import lexer/lexer
import context/context
import native/native

import stringbuffer
import process
import io/filesystem

interface ILGenerator {
    def spit(asm: String): Unit
    def beginBlock(): Unit
    def endBlock(): Unit
}

effect ILGenError(msg: String, pos: Position): Nothing / CompilerContextRequest

def ilgen_report[T] { prog: () => T / ILGenError }: T / {CompilerSettingsRegister, InternalError, CompilerContextRequest} = {
    try { prog() }
    with ILGenError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[ILGEN ERROR] "++do getWorkingFile()++" at "++show(pos)++": "++msg)
        println("\n        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        exit(1)
    }}
}

def ilgen[T](target: String) { prog: () => T / ILGenerator }: T / {CompilerSettingsRegister, ILGenError, InternalError} = {
    with stringBuffer;
    var tab = 0;

    try {
        val res = prog()
        openWrite(target, do flush())
        println("[ILGEN] IL output written to path: "++target)
        res
    } with ILGenerator {
        def spit(asm) = {
            do write("    ".repeat(tab))
            //each(0, tab){ _ => do write("    ") }
            do write(asm)
            resume(do write("\n"))
        }
        def beginBlock() = {
            tab = tab + 1
            resume(())
        }
        def endBlock() = {
            tab = tab - 1
            resume(())
        }
    }
}

def compilerStopHandler[T]() { prog: () => T / StopCompiler }: Unit / {ILGenerator, ILGenError, InternalError} = {
    try { prog(); () }
    with StopCompiler {
        println("[ILGEN] Compiler exited without any errors.")
    }
}

def ignoreStop[T]() { prog: () => T / StopCompiler }: Unit = {
    try { prog(); () }
    with StopCompiler { () }
}

def handleTokens[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ILGenError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))

    def next() = {
        with on[MissingValue].default{ <> };
        if (tokens.isEmpty)
            Token(EOF(), "", previousToken.position)
        else {
            previousToken = tokens.head
            tokens = tokens.tail
            previousToken
        }
    }

    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def matchAny(tokensToMatch) = try {
            resume(tokensToMatch.any { t => t == tokens.head.tokenType })
        } with Exception[MissingValue] {
            def raise(_, _) = resume(false)
        }
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ILGenError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ILGenError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def checkReturnOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { next() }
                else do ILGenError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            } with Exception[MissingValue] {
                def raise(_, _) = do ILGenError("Expected '"++token.show++"', got an unexpected EOF.", previousToken.position)
            }
        }
        def advance() = resume { next() }
        def rewind() = {
            tokens = Cons(previousToken, tokens)
            resume(previousToken)
        }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

def getModeFromType(t: Type) = t match {
    case Type::Bool() => Some("%ub")
    case Type::UInt() => Some("%ui")
    case Type::Int() => Some("%i")
    case Type::Float() => Some("%f")
    case Type::UByte() => Some("%ub")
    case Type::Byte() => Some("%b")
    case Type::Pointer(_) => Some("%ui")
    case Type::FunctionPointer(_, _) => Some("%ui")
    case _ => None()
}

def makeSymbol(name: QualifiedName, public: Bool) = name.mod match {
    case None() => do getWorkingModule()++"$$"++if(public){"pub"}else{"priv"}++"$$"++name.name
    case Some(mod) => mod++"$$"++if(public){"pub"}else{"priv"}++"$$"++name.name
}

def pointingType(ptr: Type) = ptr match {
    case Type::Pointer(to) => to
    case _ => unreachable(__FILE__, __LINE__)
}

def expressionGen(expr: Expression): Unit / {ILGenError, ParserContextRequest, InternalError, TokenRequest, ILGenerator, CompilerContextRequest, CompilerSettingsRegister} = expr match {
    case ExpressionList(inside, _) => {
        inside.foreach{ex => ex.expressionGen}
    }
    case Literal(value, _) => value match {
        case Literal::Bool(value) => value match {
            case true => do spit("stc %ub 1")
            case false => do spit("stc %ub 0")
        }
        case Literal::UInt(value) => do spit("stc %ui "++value.show)
        case Literal::Int(value) => do spit("stc %i "++value.show)
        case Literal::Float(value) => do spit("stc %f "++value.show)
        case Literal::UByte(value) => do spit("stc %ub "++value.show)
        case Literal::Byte(value) => do spit("stc %b "++value.show)
        case Literal::Nullptr() => do spit("stc %ui 0")
        case Literal::String(value) => do spit("raw "++value.length.show++" \""++value++"\" ;")
        case Literal::TypeLiteral(_) => ()
    }
    case Identifier(name, pos) => {
        with parser_report;
        if (do hasVar(name, true)) {
            val sign = do getVar(name)

            sign.varType.getModeFromType match {
                case Some(modeflag) => sign.global match {
                    case false => do spit("rdl "++modeflag++" "++sign.stackIndex.show)
                    case true => {
                        do spit("mov "++sign.stackIndex.show++" &ebx")
                        do spit("rda "++modeflag)
                    }
                }
                case None() =>
                    if (sign.name.startsWith("$") && sign.varType == Type::Custom(QualifiedName(Some("string"), "String")) && sign.global) {
                        do spit("stc %ui "++sign.stackIndex.show)
                    } else sign.varType match {
                        case Type::Custom(_) => {
                            // TODO: make this into a single instruction, or a couple at least based on layout size
                            do spit("mov "++sign.stackIndex.show++" &eax")
                            if (not(sign.global))
                                do spit("add %ui &bp &eax")
                            do spit("mov "++sign.varType.typeSize.show++" &ecx")
                            do spit("mov &sp &ebx")
                            do spit("mcp %s %s")
                            do spit("inc %ui &sp "++sign.varType.typeSize.show)
                        }
                        case _ => {
                            if (not(sign.global)) {
                                do spit("rdl "++sign.varType.getModeFromType.unpack++" "++sign.stackIndex.show)
                            } else {
                                do spit("mov "++sign.stackIndex.show++" &ebx")
                                do spit("rda "++sign.varType.getModeFromType.unpack)
                            }
                        }
                    }
            }
        } else if (do hasFunction(name)) {
            do spit("sad "++name.makeSymbol(do getFunctionSignature(name).unpackOrCrash.public))
        } else unreachable(__FILE__, __LINE__) 
    }
    case Call(fn, args, pos) => {
        with on[MissingValue].ignore;
        with parser_report;
        def _fncall(name: QualifiedName, pos: Position): Unit = name match {
            case QualifiedName(None(), "offset") => {
                // top of the stack is ptr, u32
                args.foreach{arg => arg.expressionGen}
                if (do getFlag("nullptr-check")) {
                    do spit("dup %ui")
                    do spit("stc %ui 0")
                    do spit("cnj %ui %equ jasl$$internal$$nullptrjump")
                }
                do spit("add %ui")
            }
            // TODO: Handle this in parser.
            case QualifiedName(None(), "sizeof") => {
                do spit("stc %ui "++args.evalType.map{t => t.typeSize}.sum.show)
            }
            // this is just an illusion
            case QualifiedName(None(), "ptrcast") => args.foreach{arg => arg.expressionGen}
            case QualifiedName(None(), "intcast") => args match {
                case Cons(expr, Cons(Literal(TypeLiteral(t), _), Nil())) => (expr.evalType.head, t) match {
                    // u32 to T
                    case (Type::UInt(), Type::Int()) => { expr.expressionGen }
                    case (Type::UInt(), Type::UInt()) => { expr.expressionGen }
                    case (Type::UInt(), Type::Byte()) => {
                        expr.expressionGen
                        do spit("mov &eax")
                        do spit("pop %ui")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }
                    case (Type::UInt(), Type::UByte()) => {
                        expr.expressionGen
                        do spit("mov &eax")
                        do spit("pop %ui")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }
                    case (Type::UInt(), Type::Float()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_U32ToFloat\"")
                    }

                    // i32 to T
                    case (Type::Int(), Type::Int()) => { expr.expressionGen }
                    case (Type::Int(), Type::UInt()) => { expr.expressionGen }
                    case (Type::Int(), Type::Byte()) => {
                        expr.expressionGen
                        do spit("mov &eax")
                        do spit("pop %i")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }
                    case (Type::Int(), Type::UByte()) => {
                        expr.expressionGen
                        do spit("mov &eax")
                        do spit("pop %i")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }
                    case (Type::Int(), Type::Float()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_I32ToFloat\"")
                    }

                    // f to T
                    case (Type::Float(), Type::Int()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_FloatToI32\"")
                    }
                    case (Type::Float(), Type::UInt()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_FloatToU32\"")
                    }
                    case (Type::Float(), Type::Byte()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_FloatToI32\"")
                        do spit("mov &eax")
                        do spit("pop %i")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }
                    case (Type::Float(), Type::UByte()) => {
                        expr.expressionGen
                        do spit("mov 4 &bl")
                        do spit("sys \"CSR_FloatToU32\"")
                        do spit("mov &eax")
                        do spit("pop %ui")
                        do spit("mov &eax &al")
                        do spit("rda &al")
                    }

                    // i8 to T
                    case (Type::Byte(), Type::UByte()) => { }
                    case (Type::Byte(), Type::Byte()) => { }
                    case (Type::Byte(), Type::Int()) => {
                        do spit("mov &al")
                        do spit("pop %b")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                    }
                    case (Type::Byte(), Type::UInt()) => {
                        do spit("mov &al")
                        do spit("pop %b")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                    }
                    case (Type::Byte(), Type::Float()) => {
                        do spit("mov &al")
                        do spit("pop %b")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                        do spit("mov 4 &bl")
                        do spit("sys CSR_I32ToFloat")
                    }

                    // u8 to T
                    case (Type::UByte(), Type::UByte()) => { }
                    case (Type::UByte(), Type::Byte()) => { }
                    case (Type::UByte(), Type::Int()) => {
                        do spit("mov &al")
                        do spit("pop %ub")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                    }
                    case (Type::UByte(), Type::UInt()) => {
                        do spit("mov &al")
                        do spit("pop %ub")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                    }
                    case (Type::UByte(), Type::Float()) => {
                        do spit("mov &al")
                        do spit("pop %b")
                        do spit("mov &al &eax")
                        do spit("rda &eax")
                        do spit("mov 4 &bl")
                        do spit("sys CSR_U32ToFloat")
                    }

                    case (_, _) => unimplemented(__FILE__, __LINE__)
                }

                case _ => unreachable(__FILE__, __LINE__)
            }
            case QualifiedName(None(), "deref") => {
                args.foreach{arg => arg.expressionGen}
                if (do getFlag("nullptr-check")) {
                    do spit("dup %ui")
                    do spit("stc %ui 0")
                    do spit("cnj %ui %equ jasl$$internal$$nullptrjump")
                }
                args.evalType match {
                    case Cons(t, Nil()) => {
                        val mode = t.getModeFromType
                        mode match {
                            case Some(modeflag) => {
                                do spit("mov &ebx")
                                do spit("pop %ui")
                                do spit("rda "++modeflag)
                            }
                            case None() => {
                                do spit("mov &eax")
                                do spit("mov &sp &ebx")
                                do spit("mov "++t.typeSize.show++" &ecx")
                                do spit("mcp %h %s")
                                do spit("inc %ui &sp "++t.typeSize.show)
                            }
                        }
                    }
                    case _ => unreachable(__FILE__, __LINE__)
                }
            }
            case QualifiedName(None(), "ref") => args match {
                case Cons(Identifier(name, _), Nil()) =>
                    if (do hasVar(name, true)){
                        val sign = do getVar(name)
                        do spit("stc %ui "++sign.stackIndex.show)
                        if (not(sign.global)) {
                            do spit("rda &bp")
                            do spit("add %ui")
                        }
                    } else if (do hasFunction(name)) {
                        val sign = do getFunctionSignature(name).unpack
                        do spit("sad "++name.makeSymbol(sign.public))
                    } else unreachable(__FILE__, __LINE__)
                case _ => do ILGenError("Can't take the address of a temporary value.", pos)
            }
            case QualifiedName(None(), "set") => args match {
                case Cons(left, Cons(right, Nil())) => {
                    if (left.evalType.map{t => t.pointingType}.compare(right.evalType){(a, b) => a == b}) {
                        left.expressionGen
                        if (do getFlag("nullptr-check")) {
                            do spit("dup %ui")
                            do spit("stc %ui 0")
                            do spit("cnj %ui %equ jasl$$internal$$nullptrjump")
                        }
                        val size = right.evalType.map{t => t.typeSize}.sum.show.show
                        right.expressionGen
                        do spit("dcr %ui &sp "++size)
                        do spit("mov &ebx")
                        do spit("mov &sp &eax")
                        do spit("mov "++size++" &ecx")
                        do spit("mcp %s %s")
                    } else do ParserError("Missmatching types in 'set' operation, given value doesn't match the pointer type. "++left.evalType.map{t => t.pointingType}.show++" vs "++right.evalType.show, pos)
                }
                case _ => unreachable(__FILE__, __LINE__)
            }
            case QualifiedName(None(), "assert") => args.all{a => a.isComptime} match {
                // TODO: handle comptimes, then come here and add static assertion
                case _ => {
                    args.foreach{arg => arg.expressionGen}
                    do spit("stc %ub 0")
                    do spit("cnj %ub %equ jasl$$internal$$assert$$fail")
                }
            }
            case QualifiedName(None(), "unreachable") => do spit("jmp jasl$$internal$$unreachable")
            case _ => {
                args.foreach{arg => arg.expressionGen}
                if (do hasFunction(name)) {
                    val sign = do getFunctionSignature(name).unpack
                    val sym = name.makeSymbol(sign.public)
                    do spit("mov "++args.evalType.map{s => s.typeSize}.sum.show++" &bl")
                    do spit("cal "++sym)
                } else {
                    val fpv = do getVar(name)
                    val fns = fpv.varType
                    if (fns is FunctionPointer(args, _)) {
                        do spit("rdl %ui "++fpv.stackIndex.show)
                        do spit("mov &ebx")
                        do spit("pop %ui")
                        do spit("mov "++args.map{a => a.typeSize}.sum.show++" &bl")
                        do spit("cal &ebx")
                    } else unreachable(__FILE__, __LINE__)
                }
            }
        }
        fn match {
            case Identifier(name, pos) => _fncall(name, pos)
            case Grouping(Identifier(name, pos), _) => _fncall(name, pos)
            case _ => 
                if (fn.evalType is Cons(FunctionPointer(arguments, _), Nil())){
                    args.foreach{arg => arg.expressionGen}
                    fn.expressionGen
                    do spit("mov &ebx")
                    do spit("pop %ui")
                    do spit("mov "++arguments.map{a => a.typeSize}.sum.show++" &bl")
                    do spit("cal &ebx")
                } else unreachable(__FILE__, __LINE__)
        }
    }
    case Initialization(name, initializers, _) => initializers.foreach{init => init.expressionGen}
    case Grouping(inside, _) => inside.expressionGen
    case Unary(unop, pos) => unop match {
        case Negation(rhs) => {
            with on[MissingValue].ignore;
            with parser_report;

            val t = rhs.evalType.head
            val ts = t.getModeFromType.unpack

            do spit("stc "++ts++" 0")
            rhs.expressionGen
            do spit("sub "++ts)
        }
        case Not(rhs) => {
            rhs.expressionGen
            do spit("stc %ub 1")
            do spit("xor %ub &bl")
            do spit("rda &bl")
        }
    }
    case Binary(binop, pos) => {
        with on[MissingValue].ignore;
        with parser_report;

        binop match {
            case Addition(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("add "++t)
            }
            case Subtraction(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("sub "++t)
            }
            case Division(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("div "++t)
            }
            case Multiplication(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("mul "++t)
            }
            case Equality(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %equ")
                do spit("rda &bl")
            }
            case Inequality(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %neq")
                do spit("rda &bl")
            }
            case Great(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %gre")
                do spit("rda &bl")
            }
            case Lesser(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %les")
                do spit("rda &bl")
            }
            case GreaterEqual(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %geq")
                do spit("rda &bl")
            }
            case LesserEqual(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                val t = lhs.evalType.head.getModeFromType.unpack
                do spit("cmp "++t++" %leq")
                do spit("rda &bl")
            }
            case And(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                do spit("and %ub &bl")
                do spit("rda &bl")
            }
            case Or(lhs, rhs) => { 
                lhs.expressionGen
                rhs.expressionGen
                do spit("or %ub &bl")
                do spit("rda &bl")
            }
        }
    }
    case Assignment(expr, rhs, pos) => {
        with parser_report;

        var addr = 0;
        var glob = false;
        var t: Type = Type::Void()

        def _setUpLeft(expr: Expression): Unit = expr match {
            case Identifier(name, _) => {
                val varsign = do getVar(name)
                addr = varsign.stackIndex
                glob = varsign.global
                t = varsign.varType
            }
            case Grouping(inside, _) => _setUpLeft(inside)
            case Dot(lhs, member, pos) => {
                with on[MissingValue].ignore;

                _setUpLeft(lhs)
                val layout = lhs.evalType.head match {
                    case Type::Custom(name) => do getLayoutSignature(name).unpack
                    case _ => unreachable(__FILE__, __LINE__)
                }
                val field = layout.fields.filter{f => f.name == member.name}.head
                addr = addr + field.stackIndex
                t = field.varType
            }
            case _ => ()
        }

        _setUpLeft(expr)
        rhs.expressionGen
        t match {
            case Type::Custom(name) => {
                do spit("mov "++addr.show++" &ebx")
                if (not(glob))
                    do spit("add %ui &bp &ebx")
                do spit("mov "++t.typeSize.show++" &ecx")
                do spit("mov &sp &eax")
                do spit("dcr %ui &eax "++t.typeSize.show)
                do spit("mcp %s %s")
            }
            case _ => glob match {
                // there is no stl instruction yet
                // case false => do spit("stl "++t.getModeFromType.unpack++" "++addr.show) 
                /*case true*/ case _ => {
                    do spit("mov "++addr.show++" &ebx")
                    if (not(glob))
                        do spit("add %ui &bp &ebx")
                    do spit("ldc "++t.getModeFromType.unpack)
                }
            }
        }
    }
    case Dot(lhs, member, pos) => {
        with parser_report;
        
        var addr = 0;
        var glob = false;
        var t: Type = Type::Void()

        def _setUpLeft(expr: Expression): Unit = expr match {
            case Identifier(name, _) => {
                val varsign = do getVar(name)
                addr = varsign.stackIndex
                glob = varsign.global
                t = varsign.varType
            }
            case Grouping(inside, _) => _setUpLeft(inside)
            case Dot(lhs, member, pos) => {
                with on[MissingValue].ignore;

                _setUpLeft(lhs)
                val layout = lhs.evalType.head match {
                    case Type::Custom(name) => do getLayoutSignature(name).unpack
                    case _ => unreachable(__FILE__, __LINE__)
                }
                val field = layout.fields.filter{f => f.name == member.name}.head
                addr = addr + field.stackIndex
                t = field.varType
            }
            case _ => ()
        }
        _setUpLeft(expr)
        t match {
            case Type::Custom(name) => {
                do spit("mov "++addr.show++" &eax")
                if (not(glob))
                    do spit("add %ui &bp &eax")
                do spit("mov "++t.typeSize.show++" &ecx")
                do spit("mov &sp &ebx")
                do spit("mcp %s %s")
                do spit("inc %ui &sp "++t.typeSize.show)
            }
            case _ => 
                if (t.getModeFromType is Some(ts)) glob match {
                    case false => do spit("rdl "++ts++" "++addr.show)
                    case true => {
                        do spit("mov "++addr.show++" &ebx")
                        do spit("ldc "++ts)
                    }
                }
                else { }
        }
    }
    case _ => ()
}

def statementGen(stmt: Statement): Unit / {ILGenError, ParserContextRequest, InternalError, TokenRequest, ILGenerator, CompilerContextRequest, CompilerSettingsRegister} = stmt match {
    case FnDefinition(sign, body, scope, _) => {
        do spit("")
        do spit(do getWorkingModule()++if(sign.public){"$$pub"}else{"$$priv"}++"$$"++sign.name++":")
        do beginBlock()
            with parser_report;
            with contextHandler(scope);
            body.foreach{stmt => stmt.statementGen}
        do endBlock()
    }
    case ReturnStmt(returns, _) => {
        with parser_report;
        returns.foreach{ret => ret.expressionGen}
        do spit("mov "++returns.evalType.map{t => t.typeSize}.sum.show++" &bl")
        do spit("ret")
    }
    case InlineAssembly(asm, _) => {
        do spit("#begin inline asm#")
        do spit(asm)
        do spit("#end inline asm#")
    }
    case VariableDefinition(signature, initializer, pos) => {
        with parser_report;
        do spit("#begin "++signature.map{s => s.show}.join(", ")++"#")
        initializer match {
            case Some(expr) => expr.expressionGen
            case None() => do spit("inc %ui &sp "++signature.map{s => s.varType.typeSize}.sum.show)
        }
        do spit("#end "++signature.map{s => s.name}.join(", ")++"#")
    }
    case Block(inside, scope, _) => {
        do beginBlock()
            with parser_report;
            contextHandler(scope) {
                inside.foreach{stmt => stmt.statementGen}
            }
            def findIndex(scope: ParserContext) = scope.parent match {
                case Some(p) => p.stackIndex
                case None() => scope.stackIndex
            }
            do spit("mov &bp &sp")
            do spit("inc %ui &sp "++findIndex(scope).show)
        do endBlock()
    }
    case Conditional(condition, body, fallback, pos) => {
        condition.expressionGen
        val conditionID = random_range(0, native::i64Max).show
        do spit("stc %ub 0")
        do spit("cnj %ub %equ jasl$$else_"++conditionID)
        body.statementGen
        fallback match {
            case Some(conditional) => {
                do spit("jmp jasl$$conditional_end_"++conditionID)
                do spit("jasl$$else_"++conditionID++":")
                conditional.statementGen
                do spit("jasl$$conditional_end_"++conditionID++":")
            }
            case None() => do spit("jasl$$else_"++conditionID++":")
        }
    }
    case WhileStmt(condition, body, id, pos) => {
        with handleLoop(id);
        val loopID = id.show
        do spit("jasl$$while_begin_"++loopID++":")
        condition.expressionGen
        do spit("stc %ub 0")
        do spit("cnj %ub %equ jasl$$while_end_"++loopID)
        body.statementGen
        do spit("jmp jasl$$while_begin_"++loopID)
        do spit("jasl$$while_end_"++loopID++":")
    }
    case ExpressionStatement(expr, _) => {
        with parser_report;
        val size = expr.evalType.map{t => t.typeSize}.sum
        expr.expressionGen
        if (size > 0)
            do spit("dcr %ui &sp "++size.show)
    }
    case BreakStmt(id, _) => do spit("jmp jasl$$while_end_"++id.show)
    case ContinueStmt(id, _) => do spit("jmp jasl$$while_begin_"++id.show)
}

def _gen(stmts: List[Statement]): Unit / {ILGenError, ParserContextRequest, InternalError, TokenRequest, ILGenerator, CompilerContextRequest, CompilerSettingsRegister} = stmts match {
    case Cons(stmt, rest) => {
        statementGen(stmt)
        _gen(rest)
    }
    case Nil() => ()
}

def gen(target: String, topLevel: ParserContext): Unit / {GlobalVariableRegister, InternalError, CompilerSettingsRegister, InternalError, CompilerContextRequest, CompilerSettingsRegister} = {
    with ilgen_report;
    with ilgen(target);
    with handleTokens(do getLexerOutput());
    with parser_report;
    with contextHandler(topLevel)
    compilerStopHandler {
        do spit("This file is generated automatically by the JASL Compiler")
        do spit("\n.prep")
        do beginBlock()
            do spit("org jasl$$internal$$globals")
            do spit("sts 256000")
            do spit("sth 64000")
        do endBlock()
        do spit(".body")
        do beginBlock()
            do spit("jasl$$internal$$nullptrcallsafeguard:")
            do beginBlock()
                do spit("#32 byte nop followed by a jump to error message function#")
                do spit("rom 0 0 0 0 0 0 0 0 ; ")
                do spit("jmp jasl$$internal$$nullptrjump")
            do endBlock()
            do spit("")
            do spit("jasl$$internal$$globals:")
            do beginBlock()
                do spit("rep %s %b 32 0")
                /*do getGlobalVarASTs().reverse.foreach{ast => {
                    do setWorkingFile(ast.filename)
                    do setWorkingModule(ast.moduleName)
                    _gen(ast.body)
                }}*/
                do getGlobalVarASTs()
                    .sortBy{(l, r) => (l, r) match {
                        case ((_, _, VariableDefinition(Cons(sl, _), _, _)), (_, _, VariableDefinition(Cons(sr, _), _, _))) => {
                            sl.stackIndex <= sr.stackIndex
                        }
                        case _ => unreachable(__FILE__, __LINE__)
                    }}
                    .foreach{case (mod, file, stmt) => {
                    do setWorkingFile(file)
                    do setWorkingModule(mod)
                    statementGen(stmt)
                }}
            do endBlock()
            do spit("")
            do spit("jasl$$internal$$main:")
            do beginBlock()
                do spit("mov 0 &bl")
                do spit("cal main$$priv$$main")
                do spit("jmp jasl$$internal$$end$$here")
            do endBlock()

        while (true) {
            val AST(filename, modulename, statements) = do emitAST()
            do setWorkingFile(filename)
            do setWorkingModule(modulename)
            _gen(statements)
        }
    }

    do spit("jasl$$internal$$assert$$fail:")
    do beginBlock()
        do spit("# TODO: rewind callstack, print and exit #")
        do spit("mov 0 &sp")
        do spit("raw 53 \"Assertion failed at runtime. Callstack not available.\" 0 ;")
        do spit("mov 4 &bl sys \"CSR_Println\"")
        do spit("jmp jasl$$internal$$end$$here\n")
    do endBlock()

    do spit("jasl$$internal$$unreachable:")
    do beginBlock()
        do spit("# TODO: rewind callstack, print and exit #")
        do spit("mov 0 &sp")
        do spit("raw 25 \"Unreachable code path hit\" 0 ;")
        do spit("mov 4 &bl sys \"CSR_Println\"")
        do spit("jmp jasl$$internal$$end$$here\n")
    do endBlock()

    do spit("jasl$$internal$$nullptrjump:")
    do beginBlock()
        do spit("mov 0 &sp")
        if (do getFlag("nullptr-check")) {
            do spit("raw 60 \"Jump to nullptr or nullptr dereferencing detected. Aborting.\" 0 ;")
        } else {
            do spit("raw 77 \"Jump to null pointer detected, check your code for nullptr function pointers.\" 0 ;")
        }
        do spit("mov 4 &bl sys \"CSR_Println\"\n")
    do endBlock()
    do spit("jasl$$internal$$end$$here:")
    do endBlock()
    do spit(".end\n")
    do spit("End of generated IL")
}
