module parser

import map
import process
import io/filesystem

import lexer/lexer
import context/context
import native/native

interface ParserContextRequest {
    def getVar(name: QualifiedName): VariableSignature / {ParserError, CompilerContextRequest}
    def hasVar(name: QualifiedName, countParent: Bool): Bool / {ParserError, CompilerContextRequest}
    def hasFunction(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def hasLayout(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def addVar(name: String, sign: VariableSignature): Unit / {ParserError, CompilerContextRequest}
    def isTopLevel(): Bool
    def stackIndex(): Int
    def createChildContext(): ParserContext
    def getCurrentContext(): ParserContext
}

interface TokenRequest {
    def matchNext(tokensToMatch: List[TokenType]): Bool // match the tokens starting from the current one
    def matchAny(tokensToMatch: List[TokenType]): Bool // match the next token to either of given ones
    def check(token: TokenType): Bool // check the current token
    def checkOrCrash(token: TokenType): Bool / ParserError
    def checkReturnOrCrash(token: TokenType): Token / ParserError
    def advance(): Token / ParserError
    def rewind(): Token
    def peek(): Token
    def previous(): Token
    def is_eof(): Bool
}

interface ReturnTypeRegister {
    def returns(returnTypes: List[Type], pos: Position): Unit / {ParserError, TokenRequest}
    def addPath(): Unit
    def isCovered(): Bool
}

interface FunctionOwnership {
    def canAccess(t: Type): Bool
}

interface GlobalVariableRegister {
    def registerGlobalVar(variable: Statement): Statement / CompilerContextRequest
    def getGlobalVarASTs(): List[AST]
}

interface LoopHandler {
    def inLoop(): Bool
    def getLoopID(): Int
}

interface Defer {
    def defer(stmt: Statement): Unit
    def getDeferIDs(t: DeferType): List[String]
    def isDeferring(): Bool
}

effect ParserError(msg: String, pos: Position): Nothing / CompilerContextRequest
// effect defer(stmt: Statement): Unit

type DeferType {
    ReturnDefer()
    LoopDefer()
}

def typeString(tl: List[Type]): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "("
    var i: Int = 0
    val l: Int = tl.size
    tl.foreachTypeList { t => {
        str = str++t.typeString()
        if (i != (l - 1))
            str = str++", "
        i = i + 1
    }}
    str++")"
}

def show(tl: List[Type]): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = tl.typeString()

def show(t: Type): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = t match {
    case Type::Bool() => "bool"
    case Type::UInt() => "u32"
    case Type::Int() => "i32"
    case Type::Float() => "float"
    case Type::UByte() => "u8"
    case Type::Byte() => "i8"
    case Type::Pointer(ptrType) => show(ptrType)++"*"
    case Type::Void() => "void"
    case Type::Custom(QualifiedName(Some(mod), name)) => mod++"::"++name
    case Type::Custom(QualifiedName(None(), name)) => name
    case Type::FunctionPointer(args, returns) => {
        var str: String = "fn ("
        var l: Int = args.size
        var i: Int = 0
        args.foreachTypeList { t => {
            str = str++t.show
            if (i != (l - 1))
                str = str++", "
            i = i + 1
        }}
        str = str++") -> ("
        l = returns.size
        i = 0
        returns.foreachTypeList  { t => {
            str = str++t.show
            if (i != (l - 1))
                str = str++", "
            i = i + 1
        }}
        str = str++")"
        str
    }
    case TypeType(inner) => "type "++inner.show
    case InternalAny() => "any"
    case Depends(_) => "depends"
    case Any(list) => "any of "++list.show
}

def typeString(t: Type): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = t.show()
// def typeString(dt: DataType): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = dt.toType().typeString()



def show(v: VariableSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++v.varType.typeSize().show()++"]["++v.stackIndex.show()++"] "
    if (v.global) str = "global "
    if (v.comptime) str = str++"comptime "
    if (v.public) str = str++"pub "
    // str = str++"let "
    if (v.mutable) str = str++"mut "
    str++v.name++": "++v.varType.typeString().show()
}

def show(f: FunctionSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = ""
    if (f.comptime) str = "comptime "
    if (f.public) str = str++"pub "
    str = str++"fn "++f.name++"("
    var l: Int = f.arguments.size
    f.arguments.foreachIndex { (i, v) => {
        //str = str++v.name++": "++v.varType.typeString()
        str = str++v.show
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++") -> ("
    l = f.returns.size
    f.returns.foreachIndex { (i, t) => {
        str = str++t.typeString()
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++")"
    if (f.ofType is Some(t)) str = str++" of type "++t.typeString()
    str
}

def show(l: LayoutSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++l.typeSize().show()++"]"
    if (l.public) str = "pub "
    if (l.wrapper) str = str++"wrapper "
    str = str++l.name++" { "
    l.fields.foreach { v => {
        str = str++v.show
    }}
    str++" }"
}



def enforceStaticType(s: VariableSignature, pos: Position): VariableSignature / {ParserError, CompilerContextRequest, InternalError} = s.varType match {
    case Type::InternalAny() => do ParserError("Type inferrence is not possible here.", pos)
    case _ => s
}

def handleLoop[T](id: Int) { prog: () => T / LoopHandler } = {
    try { prog() }
    with LoopHandler {
        def inLoop() = resume(true)
        def getLoopID() = resume(id)
    }
}

def noLoop[T]() { prog: () => T / LoopHandler } = {
    try { prog() }
    with LoopHandler {
        def inLoop() = resume(false)
        def getLoopID() = unreachable(__FILE__, __LINE__)
    }
}

def handleGlobals[T]() { prog: () => T / GlobalVariableRegister }: T / {InternalError, CompilerContextRequest} = {
    var globalVars: Map[String, List[Statement]] = map::empty(box strOrder)
    try { prog() }
    with GlobalVariableRegister {
        def registerGlobalVar(variable) = resume {
            val old = globalVars.get(do getWorkingModule()) match {
                case Some(stmts) => stmts
                case None() => Nil()
            }
            globalVars = globalVars.put(do getWorkingModule(), Cons(variable, old))
            InlineAssembly("", Position(0, 0, 0))
        }
        def getGlobalVarASTs() = {
            var asts: List[AST] = []
            globalVars.foreach { (mod, stmts) => { asts = Cons(AST("???", mod, stmts), asts) }}
            resume(asts)
        }
    }
}

def typeSize(l: LayoutSignature): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = {
    l.fields.map{ v => v.varType.typeSize() }.sum()
}

def typeSize(t: Type): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = t match {
    case Type::Bool() => 1
    case Type::UInt() => 4
    case Type::Int() => 4
    case Type::Float() => 4
    case Type::UByte() => 1
    case Type::Byte() => 1
    case Type::Pointer(_) => 4
    case Type::Void() => 0
    case Type::Custom(name) => (do getLayoutSignature(name)) match {
        case Some(signature) => signature.typeSize()
        case None() => do ParserError("Given layout '"++name.show++"' couldn't be found in this context.", (do previous()).position)
    }
    case Type::FunctionPointer(_, _) => 4
    case _ => 0
}

def foreachTypeList(list: List[Type]) { act: Type => Unit / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} }: Unit / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = list match {
    case Cons(x, xs) => {
        act(x)
        foreachTypeList(xs){act}
    }
    case Nil() => ()
}

def isComptime(stmt: Statement): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = stmt match {
    case ExpressionStatement(expr, _) => expr.isComptime
    case VariableDefinition(signature, initializer, _) => if (initializer is Some(expr)) { isComptime(expr) } else { true }
    case Conditional(condition, body, fallback, _) => isComptime(condition) && isComptime(body) && (if (fallback is Some(else_block)) { isComptime(else_block) } else { true })
    case WhileStmt(condition, body, _, _) => false // No. For now. TODO
    case FnDefinition(signature, body, scope, _) => signature.comptime
    // case LayoutDeclaration(signature, _) => true // Come on.
    case ReturnStmt(returns, _) => returns.all { r => isComptime(r) }
    case InlineAssembly(_, _) => false
    case Block(inside, _, _) => inside.all { st => st.isComptime }
    // case DeferStmt(stmt, _) => stmt.isComptime // it's syntax sugar
    case BreakStmt(_, _) => true
    case ContinueStmt(_, _) => true
}

def isComptime(op: BinaryOp): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Addition(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Subtraction(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Division(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Multiplication(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Equality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Inequality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Great(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Lesser(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case GreaterEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case LesserEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case And(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Or(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: UnaryOp): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Negation(rhs) => isComptime(rhs)
    case Not(rhs) => isComptime(rhs)
}

def isComptime(expr: Expression): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = expr match {
    case Assignment(lhs, rhs, _) => isComptime(lhs) && isComptime(rhs)
    case Initialization(typename, initializers, _) => typename match {
        case Custom(t) => do getLayoutSignature(t) match {
            case Some(s) => initializers.all{init => init.isComptime} && s.fields.all{f => not(f.mutable)}
            case _ => unreachable(__FILE__, __LINE__)
        }
        case _ => unreachable(__FILE__, __LINE__)
    }
    case Identifier(name, pos) =>
        if (do hasVar(name, true)) { (do getVar(name)).comptime }
        else if (do hasFunction(name)) {
            (do getFunctionSignature(name)) match {
                case Some(signature) => signature.comptime
                case None() => {
                    do ParserError("Couldn't find given function '"++name.show++"' in this context.", (do previous()).position)
                    unreachable(__FILE__, __LINE__)
                }
            }
        }
        else do ParserError("Couldn't find any variable or function with name '"++name.show++"' in this context.", (do previous()).position)
    case Binary(binOp, _) => isComptime(binOp)
    case Unary(unOp, _) => isComptime(unOp)
    case Grouping(expr, _) => isComptime(expr)
    case Literal(value, _) => true
    case Dot(lhs, member, _) => isComptime(lhs)
    case Scoping(_, _) => true
    case Call(fn, args, _) => isComptime(fn) && args.all { arg => isComptime(arg) }
    // case Block(inside, scope, _) => inside.all { st => isComptime(st) }
    case ExpressionList(inside, _) => inside.all { expr => expr.isComptime }
}

def getBaseType(ot: Option[Type]): Option[Type] = ot match {
    case None() => None()
    case Some(t) => t match {
        case Type::Pointer(it) => Some(it).getBaseType
        case _ => Some(t)
    }
}

def emptyParserContext(): ParserContext =
    // ParserContext(None(), 0, map::empty[String, FunctionSignature](box strOrder), map::empty[String, VariableSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))
    ParserContext(None(), 0, map::empty[String, VariableSignature](box strOrder))

def parser_report[T] { prog: () => T / ParserError }: T / {CompilerSettingsRegister, InternalError, CompilerContextRequest} = {
    try { prog() }
    with ParserError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[PARSER ERROR] "++do getWorkingFile()++" at "++show(pos)++": "++msg)
        println("\n        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        exit(1)
    }}
}

def ignoreDefer[T]() { prog: () => T / Defer }: T / {ParserError, TokenRequest, CompilerContextRequest} = {
    try { prog() }
    with Defer { 
        def defer(_) = resume(())
        def getDeferIDs(t) = resume([])
        def isDeferring() = resume(false)
    }
}

def banDefer[T]() { prog: () => T / Defer }: T / {ParserError, TokenRequest, CompilerContextRequest} = {
    try { prog() }
    with Defer { 
        def defer(_) = do ParserError("Defer statements are unsupported here.", do previous().position)
        def getDeferIDs(t) = do ParserError("Defer statements are unsupported here.", do previous().position)
        def isDeferring() = do ParserError("Defer statements are unsupported here.", do previous().position)
    }
}

def ignoreReturns[T]() { prog: () => T / ReturnTypeRegister }: T / {ParserError, TokenRequest, CompilerContextRequest, ParserContextRequest} = {
    try { prog() }
    with ReturnTypeRegister {
        def returns(_, _) = resume { }
        def addPath() = resume(())
        def isCovered() = resume(true)
    }
}

def returnHandler[T]() { prog: () => T / ReturnTypeRegister }: T / {ParserError, TokenRequest, CompilerContextRequest, ParserContextRequest} = {
    try { prog() }
    with ReturnTypeRegister {
        def returns(_, pos) = {
            do ParserError("Attempt to return from top-level detected. You can't do that sadly.", pos)
        }
        def addPath() = {
            do ParserError("Statements generating new code paths are not supported at top-level.", (do previous()).position)
        }
        def isCovered() = do ParserError("Statements generating new code paths are not supported at top-level.", (do previous()).position)
    }
}

def returnHandler[T](expected: List[Type]) { prog: () => T / ReturnTypeRegister }: T / {ParserError, TokenRequest, CompilerContextRequest, ParserContextRequest} = {
    var codePaths: Int = 1
    var returns: Int = 0
    val pos = (do previous()).position

    try {
        val res: T = prog()
        if (returns < codePaths && not(expected.all{e => e == Type::Void()}))
            do ParserError("All code paths doesn't return in this context. Paths: "++codePaths.show++", Returns: "++returns.show++". Check again please.", pos)
        res
    }
    with ReturnTypeRegister {
        def returns(returnTypes, pos) = resume {
            if (expected.compare(returnTypes){(l, r) => l == r}){
                returns = returns + 1
            } else {
                do ParserError("Missmatching return types. Type '"++returnTypes.show++"' is not allowed in this context, '"++expected.show++"' is expected.", pos)
            }
        }
        def addPath() = {
            codePaths = codePaths + 1
            resume(())
        }
        def isCovered() = resume(codePaths <= returns)
    }
}

def functionOwnershipHandler[T](ownerType: Option[Type]) { prog: () => T / FunctionOwnership }: T / {ReturnTypeRegister, ParserError, TokenRequest, CompilerContextRequest, ParserContextRequest} = {
    try { prog() }
    with FunctionOwnership {
        def canAccess(t) = ownerType match {
            case Some(owner) => Some(t).getBaseType match {
                case Some(base) => resume(owner == base)
                case None() => resume(false)
            }
            case None() => resume(false)
        }
    }
}

def contextHandler[T](_context: ParserContext) { prog: () => T / ParserContextRequest }: T / {TokenRequest, CompilerContextRequest, ParserError} = {
    var context = _context
    var stackIndex: Int = _context.stackIndex

    def _getVar(name: QualifiedName, ctx: ParserContext): VariableSignature / {ParserError, CompilerContextRequest} = ctx.variables.get(name.name) match {
        case Some(sign) => sign
        case None() => ctx.parent match {
            case Some(parent) => _getVar(name, parent)
            case None() => do getVariableSignature(name) match {
                case Some(sign) => sign
                case None() => do ParserError("Given variable '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
            }
        }
    }

    def _getFunction(name: QualifiedName): FunctionSignature / {ParserError, CompilerContextRequest} = do getFunctionSignature(name) match {
        case Some(sign) => sign
        case None() => do ParserError("Given function '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
    }

    def _getLayout(name: QualifiedName): LayoutSignature / {ParserError, CompilerContextRequest} = do getLayoutSignature(name) match {
        case Some(sign) => sign
        case None() => do ParserError("Given layout '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
    }

    try { prog() }
    with ParserContextRequest {
        def getVar(name) = resume { _getVar(name, context) }
        def hasVar(name, countParent) = resume {
            if (countParent) {
                try { _getVar(name, context); true }
                with ParserError { (_, _) => false }
            }
            else {
                context.variables.get(name.name).isDefined
            }
        } 
        def hasFunction(name) = resume {
            try { _getFunction(name); true }
            with ParserError { (_, _) => false }
        } 
        def hasLayout(name) = resume {
            try { _getLayout(name); true }
            with ParserError { (_, _) => false }
        } 
        def addVar(name, sign) = resume {
            if (context.variables.contains(name)) {
                do ParserError("Given variable '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.variables.put(name, sign))
                with ignoreDefer;
                with contextHandler(context);
                val size = sign.varType.typeSize
                stackIndex = stackIndex + size
                context = ParserContext(context.parent, context.stackIndex + size, context.variables)
            }
        }
        def stackIndex() = resume(stackIndex)
        def isTopLevel() = resume(context.parent.isEmpty)
        def createChildContext() = resume(ParserContext(Some(context), context.stackIndex, map::empty[String, VariableSignature](box strOrder)))
        def getCurrentContext() = resume(context)
    }
}

def tokenHandler[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ParserError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))

    def next() = {
        with on[MissingValue].default{ <> };
        if (tokens.isEmpty)
            Token(EOF(), "", previousToken.position)
            // do ParserError("Unexpected EOF.", previousToken.position)
        else {
            previousToken = tokens.head
            tokens = tokens.tail
            previousToken
        }
    }

    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def matchAny(tokensToMatch) = try {
            resume(tokensToMatch.any { t => t == tokens.head.tokenType })
        } with Exception[MissingValue] {
            def raise(_, _) = resume(false)
        }
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def checkReturnOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { next() }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", previousToken.position)
            } with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected '"++token.show++"', got an unexpected EOF.", previousToken.position)
            }
        }
        def advance() = resume { next() }
        def rewind() = {
            tokens = Cons(previousToken, tokens)
            resume(previousToken)
        }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

def makeFunctionType(): Type / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest, InternalError} = {
    // expect do peek() to be '('
    do checkReturnOrCrash(Symbol(LParen()))

    var arguments: List[Type] = []
    var bodyOn: Bool = true
    while (bodyOn) {
        if ((do peek()).tokenType != Symbol(RParen()))
        {
            val pos: Position = (do peek()).position
            val typename = handleTypeName()
            arguments = Cons(typename, arguments)

            (do advance()).tokenType match {
                case Symbol(RParen()) => bodyOn = false
                case Symbol(Comma()) => ()
                case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
            }
        } else {
            bodyOn = false
            val _ = do advance()
        }
    }

    do checkReturnOrCrash(Symbol(Arrow()))

    var returns: List[Type] = []
    bodyOn = true
    (do peek()).tokenType match {
        case Symbol(LParen()) => {
            do advance()
            while (bodyOn) (do peek()).tokenType match {
                case Symbol(RParen()) => {
                    do advance()
                    bodyOn = false
                }
                case _ => {
                    val t: Type = handleTypeName()
                    returns = Cons(t, returns)
                    (do peek()).tokenType match {
                        case Symbol(RParen()) => ()
                        case Symbol(Comma()) => { val _ = do advance() } 
                        case _ => do ParserError("Unexpected token '"++(do peek()).text++"' in function signature.", (do peek()).position)
                    }
                }
            }
        }
        case _ => {
            val t: Type = handleTypeName()
            returns = Cons(t, returns)
        }
    }

    FunctionPointer(arguments.reverse, returns.reverse)
}

def handleTypeName(): Type / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest, InternalError} = {
    val t: Type = (do advance()).tokenType match {
        // TODO: Type aliasing by assigning to variables.
        case IdentifierT() => do hasVar(QualifiedName(None(), do previous().text), true) match {
            case true => do getVar(QualifiedName(None(), do previous().text)).varType match {
                case Type::TypeType(t) => t
                case _ => do ParserError("Expected typename.", (do previous()).position)
            }
            case false => {
                val mod = Some((do previous()).text)
                do checkReturnOrCrash(Symbol(DoubleColon()))
                val ret = (do advance()).tokenType match {
                    // case TypeNameT(CustomT(name)) => Custom(QualifiedName(Some(mod), name))
                    case TypeNameT(t) => t.toType(mod)
                    case IdentifierT() => do hasVar(QualifiedName(mod, do previous().text), true) match {
                        case true => do getVar(QualifiedName(None(), do previous().text)).varType match {
                            case Type::TypeType(t) => t
                            case _ => do ParserError("Expected typename.", (do previous()).position)
                        }
                        case false => do ParserError("Expected typename.", (do previous()).position)
                    }
                    case _ => do ParserError("Expected typename.", (do previous()).position)
                }
                ret
            }
        }
        // case TypeNameT(CustomT(name)) => Custom(QualifiedName(Some(do getWorkingModule()), name))
        case TypeNameT(_) => (do previous()).tokenType.toType(Some(do getWorkingModule()))
        case Keyword(Fn()) => {
            // fn (params) -> returns
            makeFunctionType()
        }
        case _ => do ParserError("Expected typename.", (do previous()).position)
    }

    def check(t: Type): Type = t match {
        case Custom(name) =>
            if (do hasLayout(name)) t
            else do ParserError("Couldn't resolve type '"++t.typeString++"' in this context. Maybe you forgot to mark it 'pub'?", (do previous()).position)
        case Pointer(inner) => Pointer(inner.check)
        case _ => t
    }

    check(t)
}

def handleTypeNameNoCrashExceptUndefined(): Option[Type] / {TokenRequest, ParserContextRequest, CompilerContextRequest, ParserError, InternalError} = {
    try { Some(handleTypeName()) }
    with ParserError { (msg, pos) => if (msg.startsWith("Couldn't resolve type")) { do ParserError(msg, pos) } else { None() }}
}

def inferType(vars: List[VariableSignature], expressions: List[Type]): List[VariableSignature] = {
    vars.zipWith(expressions){ (a, b) => a.varType match {
        case Type::InternalAny() => VariableSignature(a.name, a.public, a.mutable, a.comptime, a.global, a.stackIndex, b)
        case _ => a
    }}
}
 
// This will prepass all used files and register their Tokens and names to the CompilerContext
// also will register all symbols from all modules including module names to the CompilerContext
def _prepass(): Unit / {CompilerSettingsRegister, ParserError, TokenRequest, InternalError, ParserContextRequest, CompilerContextRequest} = {
    if (not(do check(Keyword(Preprocessor(Module()))))) {
        val token = do peek()
        do ParserError("Expected 'module' statement at the beginning of the file. Got '"++token.text++"' instead.", token.position)
    }
    do advance()
    if (not (do check(IdentifierT()))) {
        val token = do peek()
        do ParserError("Expected a module name, got '"++token.text++"' instead.", token.position)
    }
    
    if (do peek().text == "jasl") {
        do ParserError("Module name 'jasl' is reserved, use something else please.", do peek().position)
    }

    do setWorkingModule((do advance()).text)
    // do registerLexerOutput([])

    debugPrint("Prepassing Module: "++do getWorkingModule())

    def handleVariable(glob: Bool, public: Bool, index: Int) = {
        val mutable = if (do check(Keyword(Mut()))) { do advance(); true } else { false }
        val identifier: Token = do checkReturnOrCrash(IdentifierT())
        val colon: Token = do checkReturnOrCrash(Symbol(Colon()))
        val typename: Type = handleTypeNameNoCrashExceptUndefined() match {
            case Some(typenm) => typenm
            case None() => do rewind().tokenType match {
                case Symbol(Assign()) => Type::InternalAny()
                case Symbol(Semicolon()) => Type::InternalAny()
                case Symbol(Comma()) => Type::InternalAny()
                case Symbol(RParen()) => Type::InternalAny()
                case _ => do ParserError("Expected '=' in variable definition.", do previous().position)
            }
        }

        VariableSignature(identifier.text, public, mutable, false, glob, index, typename)
    }
    def handleLet(public: Bool): Unit = {
        // do ParserError("Top-level global variables are not (yet) supported.", (do previous()).position)
        val pos = do previous().position

        // TODO: Type inference at top-level, requires parsing the expressions right here but anyway.

        (do peek()).tokenType match {
            case Symbol(LParen()) => {
                do advance()
                while (not(do is_eof()) && (do peek()).tokenType != Symbol(RParen())) {
                    val v: VariableSignature = handleVariable(true, public, do getGlobalStackIndex()).enforceStaticType(pos)

                    if (do hasVar(QualifiedName(None(), v.name), true))
                        do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                    
                    if ((do peek()).tokenType != Symbol(RParen()))
                        val _ = do checkReturnOrCrash(Symbol(Comma()))

                    do increaseGlobalStackIndex(v.varType.typeSize)
                    do addVariable(v)
                }
                if (do is_eof())
                    do ParserError("Expected ')' symbol but got EOF.", pos)
                val _ = do advance()
            }
            case _ => {
                val v: VariableSignature = handleVariable(true, public, do getGlobalStackIndex()).enforceStaticType(pos)
                if (do hasVar(QualifiedName(None(), v.name), true))
                    do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                do increaseGlobalStackIndex(v.varType.typeSize)
                do addVariable(v)
            }
        }
        
        while (not(do is_eof()) && (do peek()).tokenType != Symbol(Semicolon()))
            val _ = do advance()
        if (do is_eof())
            do ParserError("Unterminated statement line detected. You forgot the ';' champ.", pos)
        val _ = do advance()
    }
    def handleLayout(public: Bool, wrapper: Bool): Unit / ParserContextRequest = {
        val name: String = (do advance()).tokenType match {
            case TypeNameT(CustomT(n)) => n
            case _ => do ParserError("Expected a custom typename, got '"++(do previous()).text++"' instead.", (do previous()).position)
        }

        if ((do getLayoutSignature(QualifiedName(None(), name))) is Some(_))
            do ParserError("Multiple definition of layout '"++name++"'.", (do previous()).position)

        // to allow self-pointers
        do addLayout(LayoutSignature(name, public, wrapper, []))

        val pos: Position = (do previous()).position
        
        do checkReturnOrCrash(Symbol(LBrace()))
        var innerIndex: Int = 0
        var layout: List[VariableSignature] = []
        while ((do peek()).tokenType != Symbol(RBrace())) {
            val signature = ((do peek()).tokenType match {
                case Keyword(Pub()) => {
                    if (wrapper)
                        do ParserError("Public fields in wrapper layouts are not allowed.", (do peek()).position)
                    do advance()
                    handleVariable(false, true, innerIndex)
                }
                case _ => handleVariable(false, false, innerIndex)
            }).enforceStaticType(pos)
            if (signature.varType == Custom(QualifiedName(Some(do getWorkingModule()), name)))
                do ParserError("Recursive layouts are not allowed.", pos)
            if (layout.any { s => s.name == signature.name })
                do ParserError("Multiple definitions of field '"++signature.name++"' in layout '"++name++"'.", pos)
            do checkReturnOrCrash(Symbol(Semicolon()))
            layout = Cons(signature, layout)
            innerIndex = innerIndex + signature.varType.typeSize()
        }

        if (layout.isEmpty)
            do ParserError("Empty layouts are not supported.", pos)

        do advance()

        do addLayout(LayoutSignature(name, public, wrapper, layout.reverse))
    }
    def handleWrapper(public: Bool): Unit / ParserContextRequest = {
        do checkReturnOrCrash(Keyword(Layout()))
        handleLayout(public, true)
    }
    def handleFunction(public: Bool): Unit = {
        var name: String = ""
        val typename: Option[Type] = handleTypeNameNoCrashExceptUndefined()
        if (typename is Some(_)) {
            val _ = do checkReturnOrCrash(Symbol(DoubleColon()))
            val _ = do advance()
        }

        name = (do previous()).text

        if ((do getFunctionSignature(QualifiedName(Some(do getWorkingModule()), name))) is Some(_))
            do ParserError("Multiple definition of function '"++name++"'.", (do previous()).position)

        do checkReturnOrCrash(Symbol(LParen()))

        var stackIndexArgs: Int = 0 
        var arguments: List[VariableSignature] = typename match {
            // No implicit "this" argument
            /*case Some(t) => {
                stackIndexArgs = 4
                [ VariableSignature("this", false, true, false, false, 0, t) ]
            }
            case None() => []*/
            case _ => []
        }
        var bodyOn: Bool = true
        while (bodyOn) {
            if ((do peek()).tokenType != Symbol(RParen()))
            {
                val pos: Position = (do peek()).position
                val signature = handleVariable(false, false, stackIndexArgs)
                if (arguments.any { v => v.name == signature.name })
                    do ParserError("Multiple definitions of argument '"++signature.name++"' in function '"++name.show++"'.", pos)
                arguments = Cons(signature, arguments)

                (do advance()).tokenType match {
                    case Symbol(RParen()) => bodyOn = false
                    case Symbol(Comma()) => ()
                    case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                }

                stackIndexArgs = stackIndexArgs + signature.varType.typeSize()
            } else {
                bodyOn = false
                val _ = do advance()
            }
        }

        do checkReturnOrCrash(Symbol(Arrow()))

        var returns: List[Type] = []
        bodyOn = true
        (do peek()).tokenType match {
            case Symbol(LParen()) => {
                do advance()
                while (bodyOn) (do peek()).tokenType match {
                    case Symbol(RParen()) => {
                        do advance()
                        bodyOn = false
                    }
                    case _ => {
                        val t: Type = handleTypeName()
                        returns = Cons(t, returns)
                        (do peek()).tokenType match {
                            case Symbol(RParen()) => ()
                            case Symbol(Comma()) => { val _ = do advance() } 
                            case _ => do ParserError("Unexpected token '"++(do peek()).text++"' in function signature.", (do peek()).position)
                        }
                    }
                }
            }
            case _ => {
                val t: Type = handleTypeName()
                returns = Cons(t, returns)
            }
        }

        val pos: Position = (do checkReturnOrCrash(Symbol(LBrace()))).position
        var ident: Int = 1
        while (not(do is_eof()) && ident > 0) (do advance()).tokenType match {
            case Symbol(RBrace()) => ident = ident - 1
            case Symbol(LBrace()) => ident = ident + 1
            case Keyword(Layout()) => do ParserError("Layout definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Wrapper()) => do ParserError("Wrapper definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Pub()) => do ParserError("Public identifiers in non top-level contexts are not permitted.", (do previous()).position)
            // case Keyword(Fn()) => do ParserError("Function definitions in non top-level contexts are not permitted.", (do previous()).position)
            case _ => ()
        }
        if (do is_eof())
            do ParserError("Unterminated function body.", pos)

        do addFunction(FunctionSignature(name, public, false, typename.getBaseType, arguments.reverse, returns.reverse))
    }

    while (not(do is_eof()))
    {
        val token = do advance()

        token.tokenType match {
            case Keyword(Preprocessor(Module())) => do ParserError("A source file can only include one module directive.", token.position)
            case Keyword(Preprocessor(Include())) => {
                val token: Token = do advance()
                if (token.tokenType != LiteralT(StringT())) {
                    do ParserError("Expected a file path, got '"++token.text++"' instead.", token.position)
                }

                val fileToPass = getFile(token.text++".jasl")
                if (not(do checkDependency(fileToPass)))
                {
                    val currentFile: String = do getWorkingFile()
                    val currentModule: String = do getWorkingModule()
                    do setWorkingFile(fileToPass)
                    val tokenized: List[Token] = lexer::lex()

                    with parser_report;
                    with tokenHandler(tokenized);
                    with ignoreDefer;
                    with contextHandler(emptyParserContext());

                    tokenHandler(tokenized) {
                        _prepass()
                    }

                    debugPrint("Registering Lexer Output: "++fileToPass)
                    do registerLexerOutput(tokenized)
                    
                    do setWorkingFile(currentFile)
                    do setWorkingModule(currentModule)
                } else { () }
            }
            case Keyword(Pub()) => do advance().tokenType match {
                case Keyword(Let()) => handleLet(true)
                case Keyword(Wrapper()) => handleWrapper(true)
                case Keyword(Layout()) => handleLayout(true, false)
                case Keyword(Fn()) => handleFunction(true)
                case _ => do ParserError("Unexpected token in top-level definition. Expected one of 'let, wrapper, layout, fn'.", (do previous()).position)
            }
            case Keyword(Fn()) => handleFunction(false)
            case Keyword(Let()) => handleLet(false)
            case Keyword(Wrapper()) => handleWrapper(false)
            case Keyword(Layout()) => handleLayout(false, false)
            case EOF() => ()
            case Keyword(Defer()) => do ParserError("Defer statements at top-level are not allowed.", token.position)
            case _ => do ParserError("Unexpected token at top-level.", token.position)
        }
    }

    // do updateModule(variableSignatures, functionSignatures, layoutSignatures)
}

def prepass(tokens: List[Token], topLevel: ParserContext): Unit / {CompilerSettingsRegister, InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with ignoreDefer;
    with contextHandler(topLevel)

    tokenHandler(tokens) { // needs a separate handler since it eats
        _prepass()
    }

    debugPrint("Registering Lexer Output: "++do getWorkingFile())

    do registerLexerOutput(tokens)
}

def isSigned(t: Type): Bool = t match {
    case Type::Float() => true
    case Type::Byte() => true
    case Type::Int() => true
    case _ => false
}

def isNumeric(t: Type): Bool = t match {
    case Type::Float() => true
    case Type::Byte() => true
    case Type::UByte() => true
    case Type::UInt() => true
    case Type::Int() => true
    case _ => false
}

def __evalBin(lhs: Expression, rhs: Expression, pos: Position): List[Type] / {InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = try {
    val t1: List[Type] = lhs.evalType
    val t2: List[Type] = rhs.evalType
    if (t1.size != 1 || t2.size != 1)
        do ParserError("Binary expressions on multiple types are not allowed.", pos)
    else if (not(t1.head.isNumeric && t2.head.isNumeric))
        do ParserError("Arithmetic expressions are only allowed on numeric types.", pos)
    else if (t1.head is Custom(_))
        do ParserError("Binary expressions on custom types are not allowed.", pos)
    else if (t2.head is Custom(_))
        do ParserError("Binary expressions on custom types are not allowed.", pos)
    else if (t1.compare(t2){(a, b) => a == b})
        t1
    else
        do ParserError("Type missmatch between the sides of binary expression. Expected '"++t1.typeString++"' on both, got '"++t2.typeString++"' instead on one side.", pos)
} with Exception[MissingValue] {
    def raise(_, _) = unreachable(__FILE__, __LINE__)
}

def __evalLogic(lhs: Expression, rhs: Expression, pos: Position): List[Type] / {InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = try {
    val t1: List[Type] = lhs.evalType
    val t2: List[Type] = rhs.evalType
    if (t1.size != 1 || t2.size != 1)
        do ParserError("Logic expressions on multiple types are not allowed.", pos)
    else if (t1.head is Custom(_))
        do ParserError("Logic expressions on custom types are not allowed.", pos)
    else if (t2.head is Custom(_))
        do ParserError("Logic expressions on custom types are not allowed.", pos)
    else if (t1.compare(t2){(a, b) => a == b})
        [Type::Bool()]
    else
        do ParserError("Type missmatch between the sides of binary expression. Expected '"++t1.typeString++"' on both, got '"++t2.typeString++"' instead on one side.", pos)
} with Exception[MissingValue] {
    def raise(_, _) = unreachable(__FILE__, __LINE__)
}

def evalType(expr: Expression): List[Type] / {InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = expr match {
    case Assignment(lhs, rhs, _) => lhs.evalType
    case Initialization(name, _, pos) => [name]
    case Identifier(name, pos) => 
        if (do hasVar(name, true)) {
            [(do getVar(name)).varType]
        } else do getFunctionSignature(name) match {
            case Some(signature) => [signature.makePointer]
            case None() => do ParserError("Couldn't resolve identifier '"++name.show++"' in this context.", pos)
        }
    case Binary(binOp, pos) => binOp match {
        case Addition(lhs, rhs) => __evalBin(lhs, rhs, pos)
        case Subtraction(lhs, rhs) => __evalBin(lhs, rhs, pos)
        case Division(lhs, rhs) => __evalBin(lhs, rhs, pos)
        case Multiplication(lhs, rhs) => __evalBin(lhs, rhs, pos)
        case Equality(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case Inequality(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case Great(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case Lesser(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case GreaterEqual(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case LesserEqual(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case And(lhs, rhs) => __evalLogic(lhs, rhs, pos)
        case Or(lhs, rhs) => __evalLogic(lhs, rhs, pos)
    }
    case Unary(unOp, pos) => unOp match {
        case Negation(rhs) => {
            try {
                val t: List[Type] = rhs.evalType()
                if (t.size != 1) 
                    do ParserError("Negation operation excepts a single value as it's left hand type. Got '"++t.typeString++"' instead here.", pos)
                else if (not(t.head.isSigned)) {
                    do ParserError("Negation on unsigned types are not allowed. Explicitly cast to signed types first.", pos)
                } else { t }
            } with Exception[MissingValue] {
                def raise(_, _) = unreachable(__FILE__, __LINE__)
            }
        }
        case Not(rhs) => rhs.evalType match {
            case Cons(Type::Bool(), Nil()) => [Type::Bool()]
            case _ => do ParserError("Expected an expression of type 'bool' on right hand side.", pos)
        }
    }
    case Grouping(inside, _) => inside.evalType()
    case Literal(value, _) => value match {
        case Literal::Bool(_) => [Type::Bool()]
        case Literal::String(_) => [Type::Custom(QualifiedName(Some("string"), "String"))]
        case Literal::UInt(_) => [Type::UInt()]
        case Literal::Int(_) => [Type::Int()]
        case Literal::Float(_) => [Type::Float()]
        case Literal::UByte(_) => [Type::UByte()]
        case Literal::Byte(_) => [Type::Byte()]
        case Literal::Nullptr() => [Type::Pointer(Type::InternalAny())]
        case Literal::TypeLiteral(inner) => [Type::TypeType(inner)]
    }
    case Dot(lhs, member, _) => try {
        lhs.evalType.head match {
            case Custom(name) => {
                val layout: LayoutSignature = (do getLayoutSignature(name)).unpack()
                [layout.fields.filter{f => f.name == member.name}.head.varType]
            }
            case _ => unreachable(__FILE__, __LINE__)
        }
    } with Exception[MissingValue] {
        def raise(_, _) = unreachable(__FILE__, __LINE__)
    }
    case Scoping(name, pos) => do getFunctionSignature(name) match {
        case Some(signature) => [signature.makePointer]
        case None() => do ParserError("Type scopings are compile-time and return no types.", pos)
    }
    case Call(fn, args, pos) => fn.evalType match {
        case Cons(FunctionPointer(_, returns), Nil()) => {
            def __inner(input: List[Type], acc: List[Type]): List[Type] = input match {
                case Cons(head, rest) => head match {
                    case Depends(decide) => __inner(rest, decide(args.evalType).append(acc))
                    case _ => __inner(rest, Cons(head, acc))
                }
                case Nil() => acc.reverse
            }

            __inner(returns, [])
        }
        case _ => {
            do ParserError("Attempt to call non-function value of type "++fn.evalType.show++".", pos)
            unreachable(__FILE__, __LINE__)
        }
    }
    //case Block(inside, scope, _) => unimplemented(__FILE__, __LINE__)
    case ExpressionList(inside, pos) => {
        val returns = inside.evalType
        if (returns.isEmpty || returns.all{r => r == Type::Void()})
            [Type::Void()]
        else
            returns
    }
}

def evalType(tl: List[Expression]): List[Type] / {InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = tl match {
    case Cons(expr, rest) => expr.evalType.append(rest.evalType)
    case Nil() => Nil()
}

def handleFunctionDef(): Statement / {Defer, LoopHandler, GlobalVariableRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    // non-top level checks are already done by prepass
    if (not(do isTopLevel()))
        do ParserError("Function definitions in non top-level contexts are not permitted.", (do previous()).position)

    val pos: Position = (do previous()).position
    handleTypeNameNoCrashExceptUndefined() match {
        case Some(_) => {do advance(); val _ = do advance() }
        case None() => ()
    }
    val name: String = (do previous()).text
    val signature: FunctionSignature = do getFunctionSignature(QualifiedName(None(), name)).unpack()

    while ((do advance()).tokenType != Symbol(LBrace())) { }

    with returnHandler(signature.returns);
    with functionOwnershipHandler(signature.ofType)

    var args: Map[String, VariableSignature] = map::empty(box strOrder)
    signature.arguments.foreach { arg => {
        args = args.put(arg.name, arg)
    }}
    var functionScope = do createChildContext()
    functionScope = ParserContext(
        functionScope.parent,
        functionScope.stackIndex + signature.arguments.map{arg => arg.varType.typeSize}.sum,
        args
    )

    val bbody = handleBlockStatement(functionScope, false) match {
        case Block(i, s, pos) => (i, s)
        case _ => unreachable(__FILE__, __LINE__)
    }
    var body = bbody.first
    var scope = bbody.second
    
    try {
        body.last match {
            case Conditional(_, _, _, _) => body.last.checkReturns
            case _ => ()
        }
    } with Exception[MissingValue] {
        def raise(_, _) = ()
    }

    if (signature.returns.compare([Type::Void()]){(a, b) => a == b})
    {
        // TODO: Do a defer check here
        if (not(do isCovered())) {
            body = body.append([ReturnStmt(Nil(), (do previous()).position)])
        }

        do returns([Type::Void()], pos)
    }

    FnDefinition(signature, body, scope, pos)
}

def handleReturnStatement(): Statement / {Defer, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    if (do isTopLevel())
        do ParserError("Returns at top-level are not allowed.", (do previous()).position)

    val pos: Position = (do previous()).position
    var returns: List[Expression] = []

    (do peek()).tokenType match {
        case Symbol(Semicolon()) => {
            do advance()
            do returns([Void()], pos)
            returns = [ExpressionList([], pos)]
        }
        case _ => {
            returns = Cons(parseExpression(), returns)
            do checkReturnOrCrash(Symbol(Semicolon()))
            do returns(returns.evalType, pos)
        }
    }
    
    do isDeferring() match {
        case true => {
            debugPrint("Early exit from function, setting up defers.");
            var tmps: List[String] = []
            val defers = do getDeferIDs(ReturnDefer()).reverse
            val returnID = "jasl$$return_"++random_range(0, native::i64Max).show
            var generated: List[Statement] = []

            def setUpReturns(rets: List[Expression]): Unit = rets match {
                case Cons(head, rest) => head match {
                    case ExpressionList(exprs, _) => setUpReturns(exprs)
                    case _ => {
                        val tmpName = "tmp_return_"++random_range(0, native::i64Max).show
                        val typ = head.evalType match {
                            case Cons(t, _) => t
                            case _ => unreachable(__FILE__, __LINE__)
                        }
                        val sign = VariableSignature(tmpName, false, false, false, false, do stackIndex(), typ)
                        do addVar(tmpName, sign)
                        generated = Cons(VariableDefinition([sign], Some(head), pos), generated)
                        tmps = Cons(tmpName, tmps)
                        setUpReturns(rest)
                    }
                }
                case Nil() => ()
            }

            setUpReturns(returns)
            generated = Cons(InlineAssembly("sad "++returnID, pos), generated)
            defers.foreach{defer => {
                generated = Cons(InlineAssembly("sad "++defer, pos), generated)
            }}

            generated = Cons(
                InlineAssembly(returnID++":", pos),
                Cons(InlineAssembly("mov &edi pop %ui jmp &edi", pos), generated)
            )

            if (tmps is Nil()) Block(generated.reverse.append([ReturnStmt(returns, pos)]), do createChildContext(), pos)
            else Block(generated.reverse.append([ReturnStmt(tmps.reverse.map{tmp => Identifier(QualifiedName(None(), tmp), pos)}, pos)]), do createChildContext(), pos)
        }
        case false => ReturnStmt(returns, pos)
    }
}

def handleVariableDef(): Statement / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    // let mut name: Type = expression;
    // let name: Type = expression;
    val pos: Position = (do previous()).position
    var vars: List[VariableSignature] = []
    var stackIndex = do stackIndex()

    def handleVariable() = {
        val mutable = if (do check(Keyword(Mut()))) { do advance(); true } else { false }
        val identifier: Token = do checkReturnOrCrash(IdentifierT())
        val colon: Token = do checkReturnOrCrash(Symbol(Colon()))
        val typename: Type = handleTypeNameNoCrashExceptUndefined() match {
            case Some(typenm) => typenm
            case None() => do rewind().tokenType match {
                case Symbol(Assign()) => Type::InternalAny()
                case Symbol(Semicolon()) => Type::InternalAny()
                case Symbol(Comma()) => Type::InternalAny()
                case Symbol(RParen()) => Type::InternalAny()
                case _ => do ParserError("Expected '=' in variable definition.", do previous().position)
            }
        }

        VariableSignature(identifier.text, false, mutable, false, false, stackIndex, typename)
    }

    def inferType(vars: List[VariableSignature], expressions: List[Type]): List[VariableSignature] = {
        vars.zipWith(expressions){ (a, b) => a.varType match {
            case Type::InternalAny() => VariableSignature(a.name, a.public, a.mutable, a.comptime, a.global, a.stackIndex, b)
            case _ => a
        }}
    }

    (do peek()).tokenType match {
        case Symbol(LParen()) => {
            do advance()
            while (not(do is_eof()) && (do peek()).tokenType != Symbol(RParen())) {
                var v: VariableSignature = handleVariable()

                if (do hasVar(QualifiedName(None(), v.name), false)) {
                    v = do getVar(QualifiedName(None(), v.name))
                    if (not(v.global && do isTopLevel())) {
                        do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                    }
                }
                
                vars = Cons(v, vars)

                if ((do peek()).tokenType != Symbol(RParen()))
                    val _ = do checkReturnOrCrash(Symbol(Comma()))
                ()
            }
            if (do is_eof())
                do ParserError("Expected ')' symbol but got EOF.", pos)
            val _ = do advance()
        }
        case _ => {
            var v: VariableSignature = handleVariable()

            if (do hasVar(QualifiedName(None(), v.name), false)) {
                v = do getVar(QualifiedName(None(), v.name))
                if (not(v.global && do isTopLevel())) {
                    do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                }
            }
            vars = Cons(v, vars)
        }
    }

    vars = vars.reverse

    if (do check(Symbol(Semicolon()))) {
        do advance()
        if (vars.any{v => not(v.mutable)})
            do ParserError("Uninitialized immutable variable detected.", pos)
        else if (vars.any{v => v.varType match { case Type::InternalAny() => true; case _ => false; }})
            do ParserError("Can't infer the type of an uninitialized variable.", pos)
        else {
            vars = vars.map{v => 
                val vt = VariableSignature(v.name, v.public, v.mutable, v.comptime, v.global, stackIndex, v.varType)
                stackIndex = stackIndex + vt.varType.typeSize
                vt
            }
            val vd = VariableDefinition(vars, None(), pos)
            if (do isTopLevel() && vars.all{v => v.global})
                do registerGlobalVar(vd)
            else { 
                vars.foreach{v => {
                    if (do hasVar(QualifiedName(None(), v.name), false)) {
                        val v = do getVar(QualifiedName(None(), v.name))
                        if (not(v.global && do isTopLevel())) {
                            do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                        }
                    }
                    do addVar(v.name, v)
                }}
                vd
            }
        }
    } else {
        do checkReturnOrCrash(Symbol(Assign()))
        val expr: Expression = parseExpression();
        do checkReturnOrCrash(Symbol(Semicolon()))

        if (expr.evalType.compare(vars.map{v => v.varType}){(a, b) => a == b})
        {
            vars = vars.inferType(expr.evalType).map{v => 
                val vt = VariableSignature(v.name, v.public, v.mutable, v.comptime, v.global, stackIndex, v.varType)
                stackIndex = stackIndex + vt.varType.typeSize
                vt
            }

            val vd = VariableDefinition(vars, Some(expr), pos)
            if (do isTopLevel() && vars.all{v => v.global})
                do registerGlobalVar(vd)
            else { 
                vars.foreach{v => {
                    if (do hasVar(QualifiedName(None(), v.name), false)) {
                        val v = do getVar(QualifiedName(None(), v.name))
                        if (not(v.global && do isTopLevel())) {
                            do ParserError("Multiple definitions of variable '"++v.name++"' in this scope.", pos)
                        }
                    }
                    do addVar(v.name, v)
                }}
                vd
            }
        }
        else
            do ParserError("Missmatching types in variable definition. Expected '"++vars.map{v => v.varType}.show++"' got '"++expr.evalType.show++"'.", pos)
    }
}

def handleBlockStatement(context: ParserContext, isLoop: Bool): Statement / {Defer, LoopHandler, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var body: List[Statement] = []
    var deferred: List[Statement] = []
    val pos: Position = (do previous()).position
    val id = random_range(0, native::i64Max)
    val deferID = "jasl$$defer_"++id.show
    var chained = false

    try {
        with contextHandler(context);

        while ((do peek()).tokenType != Symbol(RBrace())) {
            body = Cons(parseStatement(), body)
        }
        do advance()

        if (deferred is Nil())
            Block(body.reverse, do getCurrentContext(), pos)
        else {
            if (chained) {
                deferred = Cons(
                    InlineAssembly("jmp jasl$$defer_end"++id.show, pos),
                    Cons(InlineAssembly(deferID++":", pos),
                    Cons(InlineAssembly("mov &edi pop %ui", pos), deferred))
                )
                deferred = deferred.append([InlineAssembly("jmp &edi", pos), InlineAssembly("jasl$$defer_end"++id.show++":", pos)])
            } else ()

            Block(body.reverse.append(deferred), do getCurrentContext(), pos)
        }
    } with Defer {
        def defer(stmt) = stmt match {
            case ExpressionStatement(Call(_, _, pos), _) => {
                if (chained)
                    do ParserError("Defer statements after early exits are problematic due to my poor engineering skills. Please rewrite all your defers to be placed before the early exit, if possible.", pos)

                deferred = Cons(stmt, deferred)
                debugPrint("Defer statement at this block, handling it. "++pos.show)
                resume(())
            }
            case _ => unreachable(__FILE__, __LINE__)
        }
        def getDeferIDs(t) = {
            chained = true
            t match {
                case ReturnDefer() => {
                    val list = do getDeferIDs(t)
                    if (deferred is Cons(_, _)) resume(Cons(deferID, list))
                    else resume(list)
                }
                case LoopDefer() => deferred match {
                    case Cons(_, _) => {
                        if (isLoop) resume([deferID])
                        else resume(Cons(deferID, do getDeferIDs(t)))
                    }
                    case _ => {
                        if (isLoop) resume([])
                        else resume(do getDeferIDs(t))
                    }
                }
            }
        }
        def isDeferring() = deferred match {
            case Cons(_, _) => resume(true)
            case _ => resume(do isDeferring())
        }
    }
}

def handleConditional(): Statement / {Defer, LoopHandler, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    with ignoreReturns;

    val pos: Position = (do previous()).position
    val condition: Expression = parseExpression()
    val scope: ParserContext = do createChildContext()

    if (not(condition.evalType.compare([Type::Bool()]){(a, b) => a == b}))
        do ParserError("If condition must return type '(bool)'. Got '"++condition.evalType.show++"' instead.", pos)

    val body: Statement = (do advance()).tokenType match {
        case Symbol(LBrace()) => handleBlockStatement(scope, false)
        case _ => do ParserError("Expected a block after if statement.", pos)
    }

    val fallback: Option[Statement] = (do peek()).tokenType match {
        case Keyword(Else()) => {
            do advance()
            (do advance()).tokenType match {
                case Symbol(LBrace()) => Some(handleBlockStatement(do createChildContext(), false))
                case Keyword(If()) => Some(handleConditional())
                case _ => do ParserError("Expected either an 'if' statement or a block after 'else'.", (do previous()).position)
            }
        }
        case _ => None()
    }

    Conditional(condition, body, fallback, pos)
}

def handleWhile(): Statement / {Defer, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    val pos: Position = (do previous()).position
    val condition: Expression = parseExpression()

    if (not(condition.evalType.compare([Type::Bool()]){(a, b) => a == b}))
        do ParserError("While condition must return type '(bool)'. Got '"++condition.evalType.show++"' instead.", pos)

    val loopID = native::random_range(0, native::i64Max)
    with handleLoop(loopID);

    val body: Statement = (do advance()).tokenType match {
        case Symbol(LBrace()) => handleBlockStatement(do createChildContext(), true)
        case _ => do ParserError("Expected a block after if statement.", pos)
    }

    WhileStmt(condition, body, loopID, pos)
}

def handleDefer(): Statement / {Defer, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    with noLoop;

    val pos = do previous().position

    // do ParserError("Defer statements are not supported yet due to my skill issue.", pos)

    val stmt: Statement = parseStatement()

    stmt match {
        case ExpressionStatement(expr, pos) => expr match {
            case Call(_, _, _) => ()
            case _ => do ParserError("Statements of this type are not allowed in defer statements.", pos)
        }
        case _ => do ParserError("Statements of this type are not allowed in defer statements.", pos)
    }

    do defer(stmt)
    InlineAssembly("#deferred#", pos)
}

// TODO: Break from nth loop
def handleBreak(): Statement / {Defer, LoopHandler, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    val pos = do previous().position

    if (do inLoop()) {
        do checkReturnOrCrash(Symbol(Semicolon()))

        if (do isDeferring()) {
            debugPrint("Early exit from loop, setting up defers.");
            val defers = do getDeferIDs(LoopDefer()).reverse
            val breakID = "jasl$$break_"++random_range(0, native::i64Max).show
            var generated: List[Statement] = []

            generated = Cons(InlineAssembly("sad "++breakID, pos), generated)
            defers.foreach{defer => {
                generated = Cons(InlineAssembly("sad "++defer, pos), generated)
            }}

            generated = Cons(
                InlineAssembly(breakID++":", pos),
                Cons(InlineAssembly("mov &edi pop %ui jmp &edi", pos), generated)
            )

            Block(generated.reverse.append([BreakStmt(do getLoopID(), pos)]), do createChildContext(), pos)
        }
        else BreakStmt(do getLoopID(), pos)
    } else {
        do ParserError("'break' statements are not allowed when not inside a loop body.", pos)
    }
}

// TODO: Continue from nth loop
def handleContinue(): Statement / {Defer, LoopHandler, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    val pos = do previous().position

    if (do inLoop()) {
        do checkReturnOrCrash(Symbol(Semicolon()))

        if (do isDeferring()) {
            debugPrint("Early exit from loop, setting up defers.");
            val defers = do getDeferIDs(LoopDefer()).reverse
            val continueID = "jasl$$continue_"++random_range(0, native::i64Max).show
            var generated: List[Statement] = []

            generated = Cons(InlineAssembly("sad "++continueID, pos), generated)
            defers.foreach{defer => {
                generated = Cons(InlineAssembly("sad "++defer, pos), generated)
            }}

            generated = Cons(
                InlineAssembly(continueID++":", pos),
                Cons(InlineAssembly("mov &edi pop %ui jmp &edi", pos), generated)
            )

            Block(generated.reverse.append([ContinueStmt(do getLoopID(), pos)]), do createChildContext(), pos)
        }
        else ContinueStmt(do getLoopID(), pos)
    } else {
        do ParserError("'continue' statements are not allowed when not inside a loop body.", pos)
    }
}

def checkReturns(conditional: Statement): Unit / {FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = conditional match {
    case ReturnStmt(returns, pos) => do returns(returns.evalType, pos)
    case Block(inside, scope, _) => {
        with ignoreDefer;
        with contextHandler(scope);
        inside.foreach{s => s.checkReturns}
    }
    case Conditional(_, body, fallback, _) => {
        with ignoreDefer;
        //contextHandler(scope) {
            do addPath()
            body.checkReturns
        //}

        fallback match {
            case Some(stmt) => {
                stmt.checkReturns
            }
            case None() => ()
        }
    }
    case _ => ()
}

def parseStatement(): Statement / {Defer, LoopHandler, GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = (do advance()).tokenType match {
    // skip these
    case Keyword(Preprocessor(_)) => {
        do advance()
        parseStatement()
    }
    case Keyword(Wrapper()) => { 
        while ((do advance()).tokenType != Symbol(RBrace())) { }
        parseStatement()
    }
    case Keyword(Layout()) => {
        while ((do advance()).tokenType != Symbol(RBrace())) { }
        parseStatement()
    }
    case Keyword(Pub()) => parseStatement()
    case EOF() => InlineAssembly("", (do previous()).position)
    case Symbol(Semicolon()) => InlineAssembly("", (do previous()).position)

    case Keyword(Break()) => handleBreak()
    case Keyword(Continue()) => handleContinue()
    case Keyword(Defer()) => handleDefer()
    case Keyword(Fn()) => handleFunctionDef()
    case Assembly() => InlineAssembly((do previous()).text, (do previous()).position)
    case Keyword(Return()) => handleReturnStatement()
    case Keyword(Let()) => handleVariableDef()
    case Symbol(LBrace()) => handleBlockStatement(do createChildContext(), false)
    case Keyword(If()) => handleConditional()
    case Keyword(While()) => handleWhile()
    case IdentifierT() =>
/*        if (do hasVar(QualifiedName(None(), do previous().text))) handleAssignment()
        else {*/
            do rewind()
            val pos: Position = do previous().position
            val expr: Expression = parseExpression()
            expr match {
                case Call(_, _, _) => ()
                case Assignment(_, _, _) => ()
                case _ => do ParserError("Expressions beside calls and assignments are not supported here.", pos)
            }
            do checkReturnOrCrash(Symbol(Semicolon()))
            ExpressionStatement(expr, pos)
//        }
    case _ => {
        do rewind()
        val pos: Position = do previous().position
        val expr: Expression = parseExpression()
        expr match {
            case Call(_, _, _) => ()
            case _ => do ParserError("Expressions beside calls are not supported here.", pos)
        }
        do checkReturnOrCrash(Symbol(Semicolon()))
            ExpressionStatement(expr, pos)
    }
        /*else if (do getFunctionSignature(QualifiedName(None(), do previous().text)).isDefined) {
            do rewind()
            ExpressionStatement(parseExpression(), do previous().position)
        }
        else unimplemented(__FILE__, __LINE__)
        */

    //case Keyword(Let()) => handleVariableDefinition()
    // case _ => do ParserError("Unexpected token '"++(do previous()).text++"', expected statement.", (do previous()).position)
}

def parsePrimary(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    try {
        val token: Token = do advance()
        token.tokenType match {
            case LiteralT(t) => t match {
                case BoolT(Some(value)) => Literal(Literal::Bool(value), token.position)
                case StringT() => {
                    val sign = VariableSignature(
                        "$tmp_"++random_range(0, native::i64Max).show,
                        true, false, true, true,
                        do getGlobalStackIndex(),
                        Type::Custom(QualifiedName(Some("string"), "String"))
                    )
                    val value = Literal(Literal::String(token.text), token.position)
                    val stmt = VariableDefinition([sign], Some(value), token.position)
                    do addVariable(sign)
                    do registerGlobalVar(stmt)
                    do increaseGlobalStackIndex(token.text.length+4)
                    Identifier(QualifiedName(Some(do getWorkingModule()), sign.name), token.position)
                    // Literal(Literal::String(token.text), token.position)
                }
                case UIntT() => Literal(Literal::UInt(token.text.toInt()), token.position)
                case IntT() => Literal(Literal::Int(token.text.toInt()), token.position)
                case FloatT() => Literal(Literal::Float(str_to_float(token.text)), token.position)
                case UByteT() => Literal(Literal::UByte(token.text.toInt()), token.position)
                case ByteT() => Literal(Literal::Byte(token.text.toInt()), token.position)
                case PointerT(VoidT()) => Literal(Literal::Nullptr(), token.position)
                case VoidT() => do ParserError("There is no such thing as a void literal. Come on.", token.position)
                case CustomT(name) => do ParserError("Really? Custom type literal?", token.position)
                case _ => do ParserError("Unexpected token '"++(do previous()).text++"'. Expected primary expression.", (do previous()).position)
            }
            case Symbol(LParen()) => {
                val expr: Expression = parseExpression()
                do checkReturnOrCrash(Symbol(RParen()))
                Grouping(expr, token.position)
            }
            case IdentifierT() => (do peek()).tokenType match {
                case Symbol(DoubleColon()) => {
                    do advance()
                    val typeOrIdent: Token = do advance()
                    typeOrIdent.tokenType match {
                        case TypeNameT(typename) => typename match {
                            case CustomT(name) => do getLayoutSignature(QualifiedName(Some(token.text), name)) match {
                                case Some(signature) => Literal(TypeLiteral(Custom(QualifiedName(Some(token.text), name))), token.position)
                                case None() => do ParserError("Couldn't find type '"++name++"' in module '"++token.text++"'.", token.position)
                            }
                            case _ => do ParserError("Type '"++typeOrIdent.text++"' is not a part of any module.", typeOrIdent.position)
                        }
                        case IdentifierT() => {
                            Identifier(QualifiedName(Some(token.text), typeOrIdent.text), token.position)
                        }
                        case _ => unreachable(__FILE__, __LINE__)
                    }
                }
                case _ => Identifier(QualifiedName(None(), token.text), token.position)
            }
            // case Symbol(LBrace()) => handleBlockStatement(do createChildContext())
            case Symbol(LBrace()) => {
                var list: List[Expression] = []

                while (not(do is_eof()) && (do peek()).tokenType != Symbol(RBrace())) {
                    list = Cons(parseExpression(), list)
                    if ((do peek()).tokenType != Symbol(RBrace()))
                        val _ = do checkReturnOrCrash(Symbol(Comma()))
                    ()
                }
                do advance()

                ExpressionList(list.reverse, token.position)
            }
            //case TypeNameT(CustomT(name)) => Scoping(QualifiedName(Some(do getWorkingModule()), name), token.position)
            case TypeNameT(t) => Literal(TypeLiteral(t.toType(Some(do getWorkingModule()))), token.position)
            case Keyword(Fn()) => Literal(TypeLiteral(makeFunctionType()), token.position)
            case _ => do ParserError("Expected expression, got unexpected token '"++token.text++"'", token.position)
        }
    } with Exception[WrongFormat] {
        def raise(_, _) = do ParserError("The number format is invalid.", (do previous()).position)
    }
}

def parsePostfix(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression = (do peek()).tokenType match {
        case Symbol(DotSym()) => try {
            val pos: Position = (do advance()).position

            def _direct(expr: Expression, member: String) = {
                val lType = expr.evalType
                if (lType.size != 1)
                    do ParserError("Member access is only supported on single values.", pos)

                lType.head match {
                    case Type::Custom(typename) => do getLayoutSignature(typename) match {
                        case Some(signature) => try {
                            if (not(do canAccess(lType.head)) && signature.wrapper) {
                                do ParserError("Can't access the fields of a wrapper type inside a function that is not owned by that type.", pos)
                            }

                            val matchingFieldL: List[VariableSignature] = signature.fields.filter{f => f.name == member}

                            if (matchingFieldL.size != 1) {
                                do ParserError("Given type '"++typename.show++"' doesn't have a field named '"++member++"'.", pos)
                            } else if (matchingFieldL.head.public || do canAccess(lType.head)){
                                Dot(expr, QualifiedName(None(), member), pos)
                            } else {
                                do ParserError("Can't access the private field '"++member++"' of type '"++lType.head.typeString++"' in a function that is not owned by the type.", pos)
                            }
                        } with Exception[MissingValue] {
                            def raise(_, _) = unreachable(__FILE__, __LINE__)
                        }
                        case None() => unreachable(__FILE__, __LINE__)
                    }
                    case FunctionPointer(_, _) => do ParserError("Sadly, you can't access the members of a function. Since they don't have any.", pos)
                    case Type::Pointer(Type::Custom(typename)) => do getLayoutSignature(typename) match {
                        case Some(signature) => try {
                            if (not(do canAccess(lType.head)) && signature.wrapper) {
                                do ParserError("Can't access the fields of a wrapper type inside a function that is not owned by that type.", pos)
                            }

                            val matchingFieldL: List[VariableSignature] = signature.fields.filter{f => f.name == member}

                            if (matchingFieldL.size != 1) {
                                do ParserError("Given type '"++typename.show++"' doesn't have a field named '"++member++"'.", pos)
                            } else if (matchingFieldL.head.public || do canAccess(lType.head)){
                                val offset = Call(Identifier(QualifiedName(None(), "offset"), pos), [expr, Literal(Literal::UInt(matchingFieldL.head.stackIndex), pos)], pos)
                                Call(Identifier(QualifiedName(None(), "ptrcast"), pos), [offset, Literal(TypeLiteral(matchingFieldL.head.varType), pos)], pos)
                            } else {
                                do ParserError("Can't access the private field '"++member++"' of type '"++lType.head.typeString++"' in a function that is not owned by the type.", pos)
                            }
                        } with Exception[MissingValue] {
                            def raise(_, _) = unreachable(__FILE__, __LINE__)
                        }
                        case None() => unreachable(__FILE__, __LINE__)
                    }
                    // case _ => do ParserError("I don't quite understand what you're trying to do here.", pos)
                    case _ => do ParserError("Invalid syntax, dot expressions are not permitted on the left-hand side "++lType.show++".", pos)
                }
            }

            def _fnCall(expr: Expression, member: String) = {
                do peek().tokenType match {
                    case Symbol(DoubleColon()) => {
                        do advance()
                        val function: String = do checkReturnOrCrash(IdentifierT()).text
                        val name = QualifiedName(Some(member), function)

                        do getFunctionSignature(name) match {
                            case Some(signature) => Dot(expr, name, pos)
                            case None() => do ParserError("Couldn't find function '"++name.show++"' in this context.", pos)
                        }
                    }
                    case Symbol(LParen()) => do getFunctionSignature(QualifiedName(None(), member)) match {
                        case Some(signature) => Dot(expr, QualifiedName(None(), member), pos)
                        case None() =>
                            do ParserError(
                                "You're either doing a member acces or a function call. A function named '"++member++"' couldn't be found and otherwise field access on temporary values are not allowed.",
                                pos
                            )
                    }
                    case _ => _direct(expr, member)
                }
            }

            def _inner(expr: Expression, pos: Position, member: String): Expression = expr match {
                case Dot(lhs, name, _) => {
                    if (do hasFunction(QualifiedName(None(), member)) || do peek().tokenType == Symbol(DoubleColon()))
                        _fnCall(expr, member)
                    else
                        _direct(expr, member)
                }
                case Grouping(inside, pos) => inside._inner(pos, member)
                case Identifier(name, _) => _fnCall(expr, member)
                case _ => {
                    if (do check(Symbol(LParen())))
                        _fnCall(expr, member)
                    else if (do check(Symbol(DoubleColon())))
                        _fnCall(expr, member)
                    else if (expr.evalType is Cons(Type::Custom(_), Nil()))
                        do ParserError("Member access can't be done on temporary values, yet. Sorry.", pos)
                    else
                        _direct(expr, member)
                }
            }

            recurse(expr._inner(pos, (do checkReturnOrCrash(IdentifierT())).text))
        } with Exception[MissingValue] {
            def raise(_, _) = unreachable(__FILE__, __LINE__)
        }
        case Symbol(LParen()) => expr match {
            case Literal(TypeLiteral(Custom(name)), pos) => do getLayoutSignature(name) match {
                case Some(signature) => {
                    val pos: Position = (do advance()).position
                    var initializer: List[Expression] = []

                    while (not(do is_eof()) && (do peek()).tokenType != Symbol(RParen())) {
                        initializer = Cons(parseExpression(), initializer)
                        if ((do peek()).tokenType != Symbol(RParen()))
                            val _ = do checkReturnOrCrash(Symbol(Comma()))
                        ()
                    }
                    if (do is_eof())
                        do ParserError("Unclosed parentheses in function call.", pos)
                    do advance()
                    initializer = initializer.reverse
                    if (not(initializer.evalType.compare(signature.fields.map{f => f.varType}){(a, b) => a == b}))
                        do ParserError("Missmatching types on type initialization. Expected '"++signature.fields.map{f => f.varType}.show++"' got '"++initializer.evalType.show++"'.", pos)
                    recurse(Initialization(Custom(name), initializer, pos))
                }
                case None() => unreachable(__FILE__, __LINE__)
            }
            case Dot(lhs, function, dpos) => do getFunctionSignature(function) match {
                case Some(signature) => {
                    val pos: Position = (do advance()).position
                    var args: List[Expression] = []

                    while (not(do is_eof()) && (do peek()).tokenType != Symbol(RParen())) {
                        args = Cons(parseExpression(), args)
                        if ((do peek()).tokenType != Symbol(RParen()))
                            val _ = do checkReturnOrCrash(Symbol(Comma()))
                        ()
                    }
                    if (do is_eof())
                        do ParserError("Unclosed parentheses in function call.", pos)
                    do advance()
                    args = args.reverse
                    args = Cons(lhs, args)
                    if (not(args.evalType.compare(signature.arguments.map{a => a.varType}){(a, b) => a == b}))
                        do ParserError("Missmatching types on function call. Expected '"++signature.arguments.map{a => a.varType}.show++"' got '"++args.evalType.show++"'.", pos)
                    recurse(Call(Identifier(function, dpos), args, pos))
                }
                case None() => unreachable(__FILE__, __LINE__)
            }
            case _ => {
                val pos: Position = (do advance()).position
                expr.evalType match {
                    case Cons(_, Cons(_, _)) =>
                        do ParserError("Can't do a function call on multiple return types.", pos)
                    case Cons(FunctionPointer(fnArgs, _), Nil()) => {
                        var args: List[Expression] = []

                        while (not(do is_eof()) && (do peek()).tokenType != Symbol(RParen())) {
                            args = Cons(parseExpression(), args)
                            if ((do peek()).tokenType != Symbol(RParen()))
                                val _ = do checkReturnOrCrash(Symbol(Comma()))
                            ()
                        }
                        if (do is_eof())
                            do ParserError("Unclosed parentheses in function call.", pos)
                        do advance()
                        args = args.reverse
                        if (not(args.evalType.compare(fnArgs){(a, b) => a == b}))
                            do ParserError("Missmatching types on function call. Expected '"++fnArgs.show++"' got '"++args.evalType.show++"'.", pos)
                        recurse(Call(expr, args, pos))
                    }
                    case _ => do ParserError("Attempt to call non-function expression.", pos)
                }
            }
        }
        case _ => expr
    }

    recurse(parsePrimary())
}

def parseUnary(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    val token: Token = do peek()
    token.tokenType match {
        case Symbol(NotSym()) => {
            do advance()
            val expr = Unary(Not(parseUnary()), token.position)
            expr.evalType
            expr
        }
        case Symbol(Minus()) => {
            do advance()
            val expr = Unary(Negation(parseUnary()), token.position)
            expr.evalType
            expr
        }
        case _ => parsePostfix()
    }
}

def parseFactor(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression = (do peek()).tokenType match {
        case Symbol(Divide()) => {
            do advance()
            val expr = Binary(Division(expr, parseUnary()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(Asterix()) => {
            do advance()
            val expr = Binary(Multiplication(expr, parseUnary()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseUnary())
}

def parseTerm(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression = (do peek()).tokenType match {
        case Symbol(Minus()) => {
            do advance()
            val expr = Binary(Subtraction(expr, parseFactor()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(Plus()) => {
            do advance()
            val expr = Binary(Addition(expr, parseFactor()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseFactor())
}

def parseComparison(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression = (do peek()).tokenType match {
        case Symbol(GreatSym()) => {
            do advance()
            val expr = Binary(Great(expr, parseTerm()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(GreatEq()) => {
            do advance()
            val expr = Binary(GreaterEqual(expr, parseTerm()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(LessSym()) => {
            do advance()
            val expr = Binary(Lesser(expr, parseTerm()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(LessEq()) => {
            do advance()
            val expr = Binary(LesserEqual(expr, parseTerm()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseTerm())
}

def parseEquality(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression =  (do peek()).tokenType match {
        case Symbol(Equals()) => {
            do advance()
            val expr = Binary(Equality(expr, parseComparison()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case Symbol(NotEq()) => {
            do advance()
            val expr = Binary(Inequality(expr, parseComparison()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseComparison())
}

def parseAndExpression(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression =  (do peek()).tokenType match {
        case Symbol(AndSym()) => {
            do advance()
            val expr = Binary(And(expr, parseEquality()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseEquality())
}

def parseOrExpression(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def recurse(expr: Expression): Expression =  (do peek()).tokenType match {
        case Symbol(OrSym()) => {
            do advance()
            val expr = Binary(Or(expr, parseAndExpression()), (do previous()).position)
            expr.evalType
            recurse(expr)
        }
        case _ => expr
    }

    recurse(parseAndExpression())
}

def parseAssignmentExpression(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    def isSuitable(expr: Expression): Bool = expr match {
        case Identifier(name, pos) => do getVar(name).mutable match {
            case true => true
            case false => do ParserError("Can't modify an immutable variable. Consider marking it 'mut'.", pos)
        }
        case Grouping(inside, _) => inside.isSuitable
        case Dot(lhs, member, pos) => lhs.evalType match {
            case Cons(Type::Custom(name), Nil()) => do getLayoutSignature(name) match {
                case Some(signature) => try {
                    if (signature.fields.filter{f => f.name == member.name}.head.mutable)
                        lhs.isSuitable
                    else
                        do ParserError("Can't modify the immutable field '"++member.show++"'.", pos)
                } with Exception[MissingValue] {
                    def raise(_, _) = unreachable(__FILE__, __LINE__)
                }
                case None() => unreachable(__FILE__, __LINE__)
            }
            // case _ => lhs.isSuitable // I don't know what this means
            case _ => false
        }
        // TODO: Add support for multi-variable assignments
        /*case ExpressionList(inside, _) => inside match {
            case Cons(head, Nil()) => head.isSuitable
            case _ => false
        }*/
        case _ => false
    }

    def recurse(expr: Expression): Expression = do peek().tokenType match {
        case Symbol(Assign()) => {
            val pos: Position = do peek().position
            if (not(expr.isSuitable))
                do ParserError("Expected an lvalue on the left side of the expression.", pos)
            do advance()
            val rhs: Expression = parseExpression()
            if (rhs.evalType.compare(expr.evalType){(a, b) => a == b})
                recurse(Assignment(expr, rhs, pos))
            else
                do ParserError("Type missmatch in assignment operation. Expected '"++expr.evalType.show++"' got '"++rhs.evalType.show++"'.", pos)
        }
        case _ => expr
    }

    recurse(parseOrExpression())
}

def parseExpression(): Expression / {GlobalVariableRegister, FunctionOwnership, ReturnTypeRegister, InternalError, TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    parseAssignmentExpression()
}

def parse(tokens: List[Token], topLevel: ParserContext): AST / {CompilerSettingsRegister, GlobalVariableRegister, InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with noLoop;
    with ignoreDefer;
    with contextHandler(topLevel);
    with ignoreReturns;
    with functionOwnershipHandler(None());

    // All top-level checks and checks for non top-level definitions are handled
    // in prepass already as well as 'module' and 'include' directives.
    var statements: List[Statement] = []

    while (not(do is_eof())) {
        statements = Cons(parseStatement(), statements)
    }

    AST(do getWorkingFile(), do getWorkingModule(), statements.reverse)
}

/*
    JASL EBNF OF EXPRESSIONS

    <expression> ::= <conditional-expression>
    <conditional-expression> ::= <logical-or-expression>
    <logical-or-expression> ::= <logical-and-expression> { "||" <logical-and-expression> }
    <logical-and-expression> ::= <equality-expression> { "&&" <equality-expression> }
    <equality-expression> ::= <comparsion-expression> { ( "==" | "!=" ) <comparsion-expression> }
    <comparsion-expression> ::= <additive-expression> { ( ">" | "<" | ">=" | "<=" ) <additive-expression> }
    <additive-expression> ::= <multiplicative-expression> { ( "+" | "-" ) <multiplicative-expression> }
    <multiplicative-expression> ::= <unary-expression> { ( "*" | "/" ) <unary-expression> }
    <unary-expression> ::= ( "-" | "!" ) <unary-expression> | <postfix-expression>
    <postfix-expression> ::= <primary-expression> { <postfix-suffix> }
    <postfix-suffix> ::= "." <identifier> | "(" [ <arg-list> ] ")" | "::" <identifier>
    <arg-list> ::= <expression> { "," <expression> }
    <primary-expression> ::= <identifier> | <literal> | "(" <expression> ")" | <block-expression>
    <block-expression> ::= "{" { <statement> } "}"
*/
