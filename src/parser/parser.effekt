module parser

import map
import process
import io/filesystem

import lexer/lexer
import context/context

record ParserContext(
    parent: Option[ParserContext],
    stackIndex: Int,
    functions: Map[String, FunctionSignature],
    variables: Map[String, VariableSignature],
    layouts: Map[String, LayoutSignature]
)

interface ParserContextRequest {
    def getVar(name: String): VariableSignature / ParserError
    def getFunction(name: String): FunctionSignature / ParserError
    def getLayout(name: String): LayoutSignature / ParserError
    def hasVar(name: String): Bool
    def hasFunction(name: String): Bool
    def hasLayout(name: String): Bool
    def addVar(name: String, sign: VariableSignature): Unit / ParserError
    def addFunction(name: String, sign: FunctionSignature): Unit / ParserError
    def addLayout(name: String, sign: LayoutSignature): Unit / ParserError
}

interface TokenRequest {
    def matchNext(tokensToMatch: List[TokenType]): Bool // match the tokens starting from the current one
    def check(token: TokenType): Bool // check the current token
    def checkOrCrash(token: TokenType): Bool / ParserError
    def checkReturnOrCrash(token: TokenType): Token / ParserError
    def advance(): Token / ParserError
    def peek(): Token
    def previous(): Token
    def is_eof(): Bool
}

effect ParserError(msg: String, pos: Position): Nothing / CompilerContextRequest

def show(t: Type): String = t match {
    case Type::Bool() => "bool"
    case Type::UInt() => "u32"
    case Type::Int() => "i32"
    case Type::Float() => "float"
    case Type::UByte() => "u8"
    case Type::Byte() => "i8"
    case Type::Pointer(ptrType) => show(ptrType)++"*"
    case Type::Void() => "void"
    case Type::Custom(Some(mod), name) => mod++"::"++name
    case Type::Custom(None(), name) => name
}

def typeString(t: Type): String / InternalError = t.show()
def typeString(dt: DataType): String / InternalError = dt.toType().typeString()

__DEBUG_START__
def show(v: VariableSignature): String / InternalError = {
    var str: String = "["++v.stackIndex.show()++"] "
    if (v.comptime) str = "comptime "
    if (v.public) str = str++"pub "
    str = str++"let "
    if (v.mutable) str = str++"mut"
    str++": "++v.varType.typeString()
}

def show(f: FunctionSignature): String / InternalError = {
    var str: String = ""
    if (f.comptime) str = "comptime "
    if (f.public) str = str++"pub "
    str = str++"fn "++f.name++"("
    var l: Int = f.arguments.size
    f.arguments.foreachIndex { (i, v) => {
        str = str++v.name++": "++v.varType.typeString()
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++") -> ("
    l = f.returns.size
    f.returns.foreachIndex { (i, t) => {
        str = str++t.typeString()
        if (i != (l - 1))
            str = str++", "
    }}
    str++")"
}

def show(l: LayoutSignature): String / InternalError = {
    var str: String = ""
    if (l.public) str = "pub "
    if (l.wrapper) str = str++"wrapper "
    str = str++l.name++" { "
    l.fields.foreach { v => {
        if (v.public) str = str++"pub "
        if (v.mutable) str = str++"mut "
        str = str++v.name++": "++v.varType.typeString()++"; "
    }}
    str++"}"
}
__DEBUG_END__

def isComptime(stmt: Statement): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = stmt match {
    case ExpressionStatement(expr, _) => isComptime(expr)
    case VariableDefinition(signature, initializer, _) => if (initializer is Some(expr)) { isComptime(expr) } else { true }
    case Conditional(condition, body, scope, fallback, _) => isComptime(condition) && isComptime(body) && (if (fallback is Some(else_block)) { isComptime(else_block) } else { true })
    case WhileStmt(condition, body, scope, _) => false // No.
    case FnDeclaration(signature, body, scope, _) => signature.comptime
    case LayoutDeclaration(signature, _) => true // Come on.
    case ReturnStmt(returns, _) => returns.all { r => isComptime(r) }
    case Assignment(lhs, rhs, _) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: BinaryOp): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Addition(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Subtraction(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Division(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Multiplication(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Equality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Inequality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Great(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Lesser(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case GreaterEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case LesserEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case And(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Or(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: UnaryOp): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Negation(rhs) => isComptime(rhs)
    case Not(rhs) => isComptime(rhs)
}

def isComptime(expr: Expression): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = expr match {
    case TypeName(_) => true
    case Identifier(name) =>
        if (do hasVar(name)) { (do getVar(name)).comptime }
        else if (do hasVar(name)) { (do getFunction(name)).comptime }
        else do ParserError("Couldn't find any variable or function with name '"++name++"' in this context.", (do previous()).position)
    case Binary(binOp) => isComptime(binOp)
    case Unary(unOp) => isComptime(unOp)
    case Grouping(expr) => isComptime(expr)
    case Literal(value) => true
    case Dot(lhs, member) => isComptime(lhs)
    case Scoping(lhs, member) => true
    case Call(fn, args) => isComptime(fn) && args.all { arg => isComptime(arg) }
    case Block(inside, scope) => inside.all { st => isComptime(st) }
}

def emptyParserContext(): ParserContext = ParserContext(None(), 0, map::empty[String, FunctionSignature](box strOrder), map::empty[String, VariableSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))

def parser_report[T] { prog: () => T / {ParserError, InternalError} }: T / {InternalError, CompilerContextRequest} = {
    try { prog() }
    with ParserError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[PARSER ERROR] "++do getWorkingFile()++" at "++show(pos)++": "++msg)
        // println("        "++msg)
        println("\n        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        exit(1)
    }}
}

def contextHandler[T](_context: ParserContext) { prog: () => T / ParserContextRequest }: T / {TokenRequest, CompilerContextRequest, ParserError} = {
    var context = _context
    try { prog() }
    with ParserContextRequest {
        def getVar(name) = resume {
            val v = context.variables.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getVar(name)
                    }
                    case None() => {
                        do ParserError("Given variable '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def getFunction(name) = resume {
            val v = context.functions.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getFunction(name)
                    }
                    case None() => {
                        do ParserError("Given function '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def getLayout(name) = resume {
            val v = context.layouts.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getLayout(name)
                    }
                    case None() => {
                        do ParserError("Given layout '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def hasVar(name) = resume(
            if (context.variables.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasVar(name)
            }
            else { false }
        )
        def hasFunction(name) = resume(
            if (context.functions.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasFunction(name)
            }
            else { false }
        )
        def hasLayout(name) = resume(
            if (context.layouts.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasLayout(name)
            }
            else { false }
        )
        def addVar(name, sign) = resume {
            if (context.variables.contains(name)) {
                do ParserError("Given variable '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables.put(name, sign), context.layouts)
            }
        }
        def addFunction(name, sign) = resume {
            if (context.functions.contains(name)) {
                do ParserError("Given function '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions.put(name, sign), context.variables, context.layouts)
            }
        }
        def addLayout(name, sign) = resume {
            if (context.layouts.contains(name)) {
                do ParserError("Given layout '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables, context.layouts.put(name, sign))
            }
        }
    }
}

def tokenHandler[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ParserError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))

    def next() = {
        if (tokens.isEmpty)
            do ParserError("Unexpected EOF.", previousToken.position)
        with on[MissingValue].default{ <> };

        previousToken = tokens.head
        tokens = tokens.tail
        previousToken
    }

    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def checkReturnOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { next() }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            } with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected '"++token.show++"', got an unexpected EOF.", previousToken.position)
            }
        }
        def advance() = resume { next() }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

// This will prepass all used files and register their Tokens and names to the CompilerContext
// also will register all symbols from all modules including module names to the CompilerContext
def _prepass(): Unit / {ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    if (not(do check(Keyword(Preprocessor(Module()))))) {
        val token = do peek()
        do ParserError("Expected 'module' statement at the beginning of the file. Got '"++token.text++"' instead.", token.position)
    }
    do advance()
    if (not (do check(IdentifierT()))) {
        val token = do peek()
        do ParserError("Expected a module name, got '"++token.text++"' instead.", token.position)
    }
    do setWorkingModule((do advance()).text)
    do registerLexerOutput([])
    println("Prepassing Module: "++do getWorkingModule())

    var variableSignatures = map::empty[String, VariableSignature](box strOrder)
    var functionSignatures = map::empty[String, FunctionSignature](box strOrder)
    var layoutSignatures = map::empty[String, LayoutSignature](box strOrder)

    def handleVariable(public: Bool, mutable: Bool): (String, VariableSignature) = {
        val identifier: Token = do checkReturnOrCrash(IdentifierT())
        val colon: Token = do checkReturnOrCrash(Symbol(Colon()))
        val typename: Type = (do advance()).tokenType match {
            case IdentifierT() => {
                val mod = (do previous()).text
                do checkReturnOrCrash(Symbol(DoubleColon()))
                (do advance()).tokenType match {
                    case TypeNameT(_) => Custom(Some(mod), (do previous()).text)
                    case _ => do ParserError("Expected typename.", (do previous()).position)
                }
            }
            case TypeNameT(_) => (do previous()).tokenType.toType()
            case _ => do ParserError("Expected typename.", (do previous()).position)
        }

        if (variableSignatures.contains(identifier.text))
            do ParserError("Multiple definition of variable '"++identifier.text++"'.", identifier.position)

        (identifier.text, VariableSignature(identifier.text, public, mutable, false, true, do getGlobalStackIndex(), typename))
    }
    def handleLet(public: Bool): Unit = (do peek()).tokenType match {
        case Keyword(Mut()) => {
            do advance()
            val (name, signature) = handleVariable(public, true)
            variableSignatures = variableSignatures.put(name, signature)
        }
        case IdentifierT() => {
            val (name, signature) = handleVariable(public, false)
            variableSignatures = variableSignatures.put(name, signature)
        }
        case _ => do ParserError("Epected keyword 'mut' or identifier after 'let'.", (do previous()).position)
    }
    def handleLayout(public: Bool, wrapper: Bool): Unit = {
        val name: String = (do advance()).tokenType match {
            case TypeNameT(CustomT(n)) => n
            case _ => do ParserError("Expected a custom typename, got '"++(do previous()).text++"' instead.", (do previous()).position)
        }

        if (layoutSignatures.contains(name))
            do ParserError("Multiple definition of layout '"++name++"'.", (do previous()).position)

        val pos: Position = (do previous()).position
        
        do checkReturnOrCrash(Symbol(LBrace()))
        var layout: List[VariableSignature] = []
        while ((do peek()).tokenType != Symbol(RBrace())) {
            val (_, signature) = (do peek()).tokenType match {
                case Keyword(Pub()) => {
                    do advance()
                    (do peek()).tokenType match {
                        case Keyword(Mut()) => {
                            do advance()
                            handleVariable(true, true)
                        }
                        case _ => handleVariable(true, false)
                    }
                }
                case Keyword(Mut()) => {
                    do advance()
                    handleVariable(false, true)
                }
                case _ => handleVariable(false, false)
            }
            do checkReturnOrCrash(Symbol(Semicolon()))
            layout = Cons(signature, layout)
        }

        if (layout.isEmpty)
            do ParserError("Empty layouts are not supported.", pos)

        do advance()

        layoutSignatures = layoutSignatures.put(name, LayoutSignature(name, public, wrapper, layout))
    }
    def handleWrapper(public: Bool): Unit = {
        do checkReturnOrCrash(Keyword(Layout()))
        handleLayout(public, true)
    }
    def handleFunction(public: Bool): Unit = {
        var name: String = ""
        (do advance()).tokenType match {
            case TypeNameT(typename) => {
                do checkReturnOrCrash(Symbol(DoubleColon()))
                val ident: String = (do checkReturnOrCrash(IdentifierT())).text
                name = typename.typeString()++"::"++ident
            }
            case IdentifierT() => name = (do previous()).text
            case _ => do ParserError("Expected type name or identifier, got '"++(do previous()).text++"' instead.", (do previous()).position)
        }

        if (functionSignatures.contains(name))
            do ParserError("Multiple definition of function '"++name++"'.", (do previous()).position)

        do checkReturnOrCrash(Symbol(LParen()))

        var arguments: List[VariableSignature] = []
        var bodyOn: Bool = true
        while (bodyOn) {
            if ((do peek()).tokenType != Symbol(RParen()))
            {
                val (_, signature) = handleVariable(false, true)
                arguments = Cons(signature, arguments)

                (do advance()).tokenType match {
                    case Symbol(RParen()) => bodyOn = false
                    case Symbol(Comma()) => ()
                    case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                }
            } else {
                bodyOn = false
                val _ = do advance()
            }
        }

        do checkReturnOrCrash(Symbol(Arrow()))

        var returns: List[Type] = []
        bodyOn = true
        (do advance()).tokenType match {
            case IdentifierT() => {
                val mod: String = (do previous()).text
                do checkReturnOrCrash(Symbol(DoubleColon()))
                (do advance()).tokenType match {
                    case TypeNameT(CustomT(name)) => returns = Cons(Custom(Some(mod), name), returns)
                    case _ => do ParserError("Expected a custom type name.", (do previous()).position)
                }
            }
            case TypeNameT(typename) =>
                returns = Cons(typename.toType(), returns)
            case Symbol(LParen()) => {
                while (bodyOn) (do advance()).tokenType match {
                    case IdentifierT() => {
                        val mod: String = (do previous()).text
                        do checkReturnOrCrash(Symbol(DoubleColon()))
                        (do advance()).tokenType match {
                            case TypeNameT(CustomT(name)) => returns = Cons(Custom(Some(mod), name), returns)
                            case _ => do ParserError("Expected a custom type name.", (do previous()).position)
                        }
                        (do advance()).tokenType match {
                            case Symbol(RParen()) => bodyOn = false
                            case Symbol(Comma()) => ()
                            case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                        }
                    }
                    case TypeNameT(typename) => {
                        returns = Cons(typename.toType(), returns)
                        (do advance()).tokenType match {
                            case Symbol(RParen()) => bodyOn = false
                            case Symbol(Comma()) => ()
                            case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                        }
                    }
                    case _ => do ParserError("Expected type name, got '"++(do previous()).text++"' instead.", (do previous()).position)
                }
            }
            case _ => do ParserError("Expected return type(s), got '"++(do previous()).text++"'. instead", (do previous()).position)
        }

        val pos: Position = (do checkReturnOrCrash(Symbol(LBrace()))).position
        var ident: Int = 1
        while (not(do is_eof()) && ident > 0) (do advance()).tokenType match {
            case Symbol(RBrace()) => ident = ident - 1
            case Symbol(LBrace()) => ident = ident + 1
            case _ => ()
        }
        if (do is_eof())
            do ParserError("Unterminated function body.", pos)

        functionSignatures = functionSignatures.put(name, FunctionSignature(name, public, false, arguments, returns))
    }

    while (not(do is_eof()))
    {
        val token = do advance()

        token.tokenType match {
            case Keyword(Preprocessor(Module())) => do ParserError("A source file can only include one module directive.", token.position)
            case Keyword(Preprocessor(Include())) => {
                val token: Token = do advance()
                if (token.tokenType != LiteralT(StringT())) {
                    do ParserError("Expected a file path, got '"++token.text++"' instead.", token.position)
                }

                if (not (do checkDependency(token.text)))
                {
                    val currentFile: String = do getWorkingFile()
                    val currentModule: String = do getWorkingModule()
                    do setWorkingFile(token.text)
                    val tokenized: List[Token] = lexer::lex()

                    with parser_report;
                    with tokenHandler(tokenized);
                    with contextHandler(emptyParserContext());

                    tokenHandler(tokenized) {
                        _prepass()
                    }

__DEBUG_START__
                    println("Registering Lexer Output: "++do getWorkingModule())
__DEBUG_END__
                    do registerLexerOutput(tokenized)
                    
                    do setWorkingFile(currentFile)
                    do setWorkingModule(currentModule)
                } else { () }
            }
            case Keyword(Pub()) => do advance().tokenType match {
                case Keyword(Let()) => handleLet(true)
                case Keyword(Wrapper()) => handleWrapper(true)
                case Keyword(Layout()) => handleLayout(true, false)
                case Keyword(Fn()) => handleFunction(true)
                case _ => do ParserError("Unexpected token in top-level definition. Expected one of 'let, wrapper, layout, fn'.", (do previous()).position)
            }
            case Keyword(Fn()) => handleFunction(false)
            case Keyword(Let()) => handleLet(false)
            case Keyword(Wrapper()) => handleWrapper(false)
            case Keyword(Layout()) => handleLayout(false, false)
            case _ => {}
        }
    }

    do updateModule(variableSignatures, functionSignatures, layoutSignatures)
}

def prepass(tokens: List[Token]): Unit / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);

    tokenHandler(tokens) { // needs a separate handler since it eats
        _prepass()
    }

__DEBUG_START__
    println("Registering Lexer Output: "++do getWorkingModule())
__DEBUG_END__

    do registerLexerOutput(tokens)
}

def parseExpression(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    AST(do getWorkingModule(), [])
}

def parse(tokens: List[Token]): AST / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext());

    parseExpression()
}

/*
    JASL EBNF OF EXPRESSIONS

    <expression> ::= <conditional-expression>
    <conditional-expression> ::= <logical-or-expression>
    <logical-or-expression> ::= <logical-and-expression> { "||" <logical-and-expression> }
    <logical-and-expression> ::= <equality-expression> { "&&" <equality-expression> }
    <equality-expression> ::= <relational-expression> { ( "==" | "!=" ) <relational-expression> }
    <relational-expression> ::= <additive-expression> { ( ">" | "<" | ">=" | "<=" ) <additive-expression> }
    <additive-expression> ::= <multiplicative-expression> { ( "+" | "-" ) <multiplicative-expression> }
    <multiplicative-expression> ::= <unary-expression> { ( "*" | "/" ) <unary-expression> }
    <unary-expression> ::= ( "-" | "!" | "not" ) <unary-expression> | <postfix-expression>
    <postfix-expression> ::= <primary-expression> { <postfix-suffix> }
    <postfix-suffix> ::= "." <identifier> | "(" [ <arg-list> ] ")" | "::" <identifier>
    <arg-list> ::= <expression> { "," <expression> }
    <primary-expression> ::= <identifier> | <literal> | "(" <expression> ")" | <block-expression>
    <block-expression> ::= "{" { <statement> } "}"
*/
