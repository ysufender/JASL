module parser

import map
import process
import io/filesystem

import lexer/lexer
import context/context

record ParserContext(
    parent: Option[ParserContext],
    stackIndex: Int,
    functions: Map[String, FunctionSignature],
    variables: Map[String, VariableSignature],
    layouts: Map[String, LayoutSignature]
)

interface ParserContextRequest {
    def getVar(name: String): VariableSignature / ParserError
    def getFunction(name: String): FunctionSignature / ParserError
    def getLayout(name: String): LayoutSignature / ParserError
    def hasVar(name: String): Bool
    def hasFunction(name: String): Bool
    def hasLayout(name: String): Bool
    def addVar(name: String, sign: VariableSignature): Unit / ParserError
    def addFunction(name: String, sign: FunctionSignature): Unit / ParserError
    def addLayout(name: String, sign: LayoutSignature): Unit / ParserError
}

effect ParserError(msg: String, pos: Position): Nothing / CompilerContextRequest

def show(t: Type): String = t match {
    case Type::Bool() => "bool"
    case Type::UInt() => "u32"
    case Type::Int() => "i32"
    case Type::Float() => "float"
    case Type::UByte() => "u8"
    case Type::Byte() => "i8"
    case Type::Pointer(ptrType) => show(ptrType)++"*"
    case Type::Void() => "void"
    case Type::Custom(name) => name
}

def isComptime(stmt: Statement): Bool / {ParserContextRequest, ParserError} = stmt match {
    case ExpressionStatement(expr, _) => isComptime(expr)
    case VariableDefinition(signature, initializer, _) => if (initializer is Some(expr)) { isComptime(expr) } else { true }
    case Conditional(condition, body, scope, fallback, _) => isComptime(condition) && isComptime(body) && (if (fallback is Some(else_block)) { isComptime(else_block) } else { true })
    case WhileStmt(condition, body, scope, _) => false // No.
    case FnDeclaration(signature, body, scope, _) => signature.comptime
    case LayoutDeclaration(signature, _) => true // Come on.
    case ReturnStmt(returns, _) => returns.all { r => isComptime(r) }
    case Assignment(lhs, rhs, _) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: BinaryOp): Bool / {ParserContextRequest, ParserError} = op match {
    case Addition(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Subtraction(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Division(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Multiplication(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Equality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Inequality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Great(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Lesser(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case GreaterEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case LesserEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case And(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Or(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: UnaryOp): Bool / {ParserContextRequest, ParserError} = op match {
    case Negation(rhs) => isComptime(rhs)
    case Not(rhs) => isComptime(rhs)
}

def isComptime(expr: Expression): Bool / {ParserContextRequest, ParserError} = expr match {
    case TypeName(_) => true
    case Identifier(name) => (do hasVar(name) || do hasFunction(name) || do hasLayout(name))
    case Binary(binOp) => isComptime(binOp)
    case Unary(unOp) => isComptime(unOp)
    case Grouping(expr) => isComptime(expr)
    case Literal(value) => true
    case Dot(lhs, member) => isComptime(lhs)
    case Scoping(lhs, member) => true
    case Call(fn, args) => isComptime(fn) && args.all { arg => isComptime(arg) }
    case Block(inside, scope) => inside.all { st => isComptime(st) }
}

interface TokenRequest {
    def matchNext(tokensToMatch: List[TokenType]): Bool // match the tokens starting from the current one
    def check(token: TokenType): Bool // check the current token
    def checkOrCrash(token: TokenType): Bool / ParserError
    def advance(): Token / ParserError
    def peek(): Token
    def previous(): Token
    def is_eof(): Bool
}

def emptyParserContext(): ParserContext = ParserContext(None(), 0, map::empty[String, FunctionSignature](box strOrder), map::empty[String, VariableSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))

def parser_report[T] { prog: () => T / {ParserError, InternalError} }: T / {InternalError, CompilerContextRequest} = {
    try { prog() }
    with ParserError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[PARSER ERROR] "++do getWorkingFile()++" at "++show(pos))
        println("        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        println("        "++msg)
        exit(1)
    }}
}

def contextHandler[T](_context: ParserContext) { prog: () => T / ParserContextRequest }: T / {TokenRequest, CompilerContextRequest} = {
    var context = _context
    try { prog() }
    with ParserContextRequest {
        def getVar(name) = resume {
            val v = context.variables.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getVar(name)
                    }
                    case None() => {
                        do ParserError("Given variable '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def getFunction(name) = resume {
            val v = context.functions.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getFunction(name)
                    }
                    case None() => {
                        do ParserError("Given function '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def getLayout(name) = resume {
            val v = context.layouts.get(name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getLayout(name)
                    }
                    case None() => {
                        do ParserError("Given layout '"++name++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
        def hasVar(name) = resume(
            if (context.variables.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasVar(name)
            }
            else { false }
        )
        def hasFunction(name) = resume(
            if (context.functions.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasFunction(name)
            }
            else { false }
        )
        def hasLayout(name) = resume(
            if (context.layouts.contains(name)) { true }
            else if (context.parent is Some(parent)) {
                with contextHandler(parent);
                do hasLayout(name)
            }
            else { false }
        )
        def addVar(name, sign) = resume {
            if (context.variables.contains(name)) {
                do ParserError("Given variable '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables.put(name, sign), context.layouts)
            }
        }
        def addFunction(name, sign) = resume {
            if (context.functions.contains(name)) {
                do ParserError("Given function '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions.put(name, sign), context.variables, context.layouts)
            }
        }
        def addLayout(name, sign) = resume {
            if (context.layouts.contains(name)) {
                do ParserError("Given layout '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables, context.layouts.put(name, sign))
            }
        }
    }
}

def tokenHandler[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ParserError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))
    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def advance() = resume {
            if (tokens.isEmpty)
                do ParserError("Unexpected EOF.", previousToken.position)
            with on[MissingValue].default{ <> };

            previousToken = tokens.head
            tokens = tokens.tail
            previousToken
        }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

// This will prepass all used files and register their Tokens and names to the CompilerContext
def _prepass(): Unit / {ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    if (not(do check(Keyword(Preprocessor(Module()))))) {
        val token = do peek()
        do ParserError("Expected 'module' statement at the beginning of the file. Got '"++token.text++"' instead.", token.position)
    }
    do advance()
    if (not (do check(IdentifierT()))) {
        val token = do peek()
        do ParserError("Expected a module name, got '"++token.text++"' instead.", token.position)
    }
    do setWorkingModule((do advance()).text)
    do registerLexerOutput([])
    println("Prepassing Module: "++do getWorkingModule())

    val variableSignatures = map::empty[String, VariableSignature](box strOrder)
    val functionSignatures = map::empty[String, FunctionSignature](box strOrder)
    val layoutSignatures = map::empty[String, LayoutSignature](box strOrder)

    while (not(do is_eof()))
    {
        val token = do advance()
        token.tokenType match {
            case Keyword(Preprocessor(Module())) => do ParserError("A source file can only include one module directive.", token.position)
            case Keyword(Preprocessor(Include())) => {
                val token: Token = do advance()
                if (token.tokenType != LiteralT(StringT())) {
                    do ParserError("Expected a file path, got '"++token.text++"' instead.", token.position)
                }

                if (not (do checkDependency(token.text)))
                {
                    val currentFile: String = do getWorkingFile()
                    val currentModule: String = do getWorkingModule()
                    do setWorkingFile(token.text)
                    val tokenized: List[Token] = lexer::lex()

                    with parser_report;
                    with tokenHandler(tokenized);
                    with contextHandler(emptyParserContext());

                    tokenHandler(tokenized) {
                        _prepass()
                    }

                    println("Registering Lexer Output: "++do getWorkingModule())
                    do registerLexerOutput(tokenized)
                    
                    do setWorkingFile(currentFile)
                    do setWorkingModule(currentModule)
                } else { do advance(); () }
            }
            case Keyword(Pub()) => {
                //  fn, wrapper, layout, 
            }
            case Keyword(Fn()) => {}
            case Keyword(Let()) => {}
            case Keyword(Wrapper()) => {
                do checkOrCrash(Keyword(Layout()))
                ()
            }
            case _ => {}
        }
    }

    do updateModule(variableSignatures, functionSignatures, layoutSignatures)
}

def prepass(tokens: List[Token]): Unit / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);

    tokenHandler(tokens) { // needs a separate handler since it eats
        _prepass()
    }

    println("Registering Lexer Output: "++do getWorkingModule())
    do registerLexerOutput(tokens)
}

def parseExpression(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    AST(do getWorkingModule(), [])
}

def parse(tokens: List[Token]): AST / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext());

    parseExpression()
}

/*
    JASL EBNF OF EXPRESSIONS

    <expression> ::= <conditional-expression>
    <conditional-expression> ::= <logical-or-expression>
    <logical-or-expression> ::= <logical-and-expression> { "||" <logical-and-expression> }
    <logical-and-expression> ::= <equality-expression> { "&&" <equality-expression> }
    <equality-expression> ::= <relational-expression> { ( "==" | "!=" ) <relational-expression> }
    <relational-expression> ::= <additive-expression> { ( ">" | "<" | ">=" | "<=" ) <additive-expression> }
    <additive-expression> ::= <multiplicative-expression> { ( "+" | "-" ) <multiplicative-expression> }
    <multiplicative-expression> ::= <unary-expression> { ( "*" | "/" ) <unary-expression> }
    <unary-expression> ::= ( "-" | "!" | "not" ) <unary-expression> | <postfix-expression>
    <postfix-expression> ::= <primary-expression> { <postfix-suffix> }
    <postfix-suffix> ::= "." <identifier> | "(" [ <arg-list> ] ")" | "::" <identifier>
    <arg-list> ::= <expression> { "," <expression> }
    <primary-expression> ::= <identifier> | <literal> | "(" <expression> ")" | <block-expression>
    <block-expression> ::= "{" { <statement> } "}"
*/
