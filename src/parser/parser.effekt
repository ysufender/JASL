module parser

import map
import process
import io/filesystem

import lexer/lexer
import context/context

interface ParserContextRequest {
    def getVar(name: QualifiedName): VariableSignature / {ParserError, CompilerContextRequest}
    def getFunction(name: QualifiedName): FunctionSignature / {ParserError, CompilerContextRequest}
    def getLayout(name: QualifiedName): LayoutSignature / {ParserError, CompilerContextRequest}
    def hasVar(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def hasFunction(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def hasLayout(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def addVar(name: String, sign: VariableSignature): Unit / ParserError
    def addFunction(name: String, sign: FunctionSignature): Unit / ParserError
    def addLayout(name: String, sign: LayoutSignature): Unit / ParserError
    def isTopLevel(): Bool
}

interface TokenRequest {
    def matchNext(tokensToMatch: List[TokenType]): Bool // match the tokens starting from the current one
    def matchAny(tokensToMatch: List[TokenType]): Bool // match the next token to either of given ones
    def check(token: TokenType): Bool // check the current token
    def checkOrCrash(token: TokenType): Bool / ParserError
    def checkReturnOrCrash(token: TokenType): Token / ParserError
    def advance(): Token / ParserError
    def peek(): Token
    def previous(): Token
    def is_eof(): Bool
}

effect ParserError(msg: String, pos: Position): Nothing / CompilerContextRequest

def typeSize(l: LayoutSignature): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = l.fields.map{ v => v.varType.typeSize() }.sum()

def typeSize(t: Type): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = t match {
    case Type::Bool() => 1
    case Type::UInt() => 4
    case Type::Int() => 4
    case Type::Float() => 4
    case Type::UByte() => 1
    case Type::Byte() => 1
    case Type::Pointer(_) => 4
    case Type::Void() => 0
    case Type::Custom(name) => (do getLayout(name)).typeSize()
}

def show(t: Type): String = t match {
    case Type::Bool() => "bool"
    case Type::UInt() => "u32"
    case Type::Int() => "i32"
    case Type::Float() => "float"
    case Type::UByte() => "u8"
    case Type::Byte() => "i8"
    case Type::Pointer(ptrType) => show(ptrType)++"*"
    case Type::Void() => "void"
    case Type::Custom(QualifiedName(Some(mod), name)) => mod++"::"++name
    case Type::Custom(QualifiedName(None(), name)) => name
}

def typeString(t: Type): String = t.show()
def typeString(dt: DataType): String = dt.toType().typeString()

__DEBUG_START__
def show(v: VariableSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++v.varType.typeSize().show()++"]["++v.stackIndex.show()++"] "
    if (v.comptime) str = "comptime "
    if (v.public) str = str++"pub "
    // str = str++"let "
    if (v.mutable) str = str++"mut "
    str++v.name++": "++v.varType.typeString().show()
}

def show(f: FunctionSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = ""
    if (f.comptime) str = "comptime "
    if (f.public) str = str++"pub "
    str = str++"fn "++f.name++"("
    var l: Int = f.arguments.size
    f.arguments.foreachIndex { (i, v) => {
        //str = str++v.name++": "++v.varType.typeString()
        str = str++v.show
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++") -> ("
    l = f.returns.size
    f.returns.foreachIndex { (i, t) => {
        str = str++t.typeString()
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++")"
    if (f.ofType is Some(t)) str = str++" of type "++t.typeString()
    str
}

def show(l: LayoutSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++l.typeSize().show()++"]"
    if (l.public) str = "pub "
    if (l.wrapper) str = str++"wrapper "
    str = str++l.name++" { "
    l.fields.foreach { v => {
        str = str++v.show
        /*
            if (v.public) str = str++"pub "
            if (v.mutable) str = str++"mut "
            str = str++v.name++": "++v.varType.typeString()++"; "
        */
    }}
    str++"}"
}
__DEBUG_END__

def isComptime(stmt: Statement): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = stmt match {
    case ExpressionStatement(expr, _) => isComptime(expr)
    case VariableDefinition(signature, initializer, _) => if (initializer is Some(expr)) { isComptime(expr) } else { true }
    case Conditional(condition, body, scope, fallback, _) => isComptime(condition) && isComptime(body) && (if (fallback is Some(else_block)) { isComptime(else_block) } else { true })
    case WhileStmt(condition, body, scope, _) => false // No.
    case FnDefinition(signature, body, scope, _) => signature.comptime
    // case LayoutDeclaration(signature, _) => true // Come on.
    case ReturnStmt(returns, _) => returns.all { r => isComptime(r) }
    case Assignment(lhs, rhs, _) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: BinaryOp): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Addition(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Subtraction(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Division(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Multiplication(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Equality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Inequality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Great(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Lesser(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case GreaterEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case LesserEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case And(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Or(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: UnaryOp): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Negation(rhs) => isComptime(rhs)
    case Not(rhs) => isComptime(rhs)
}

def isComptime(expr: Expression): Bool / {ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = expr match {
    case TypeName(_) => true
    case Identifier(name) =>
        if (do hasVar(name)) { (do getVar(name)).comptime }
        else if (do hasVar(name)) { (do getFunction(name)).comptime }
        else do ParserError("Couldn't find any variable or function with name '"++name.show++"' in this context.", (do previous()).position)
    case Binary(binOp) => isComptime(binOp)
    case Unary(unOp) => isComptime(unOp)
    case Grouping(expr) => isComptime(expr)
    case Literal(value) => true
    case Dot(lhs, member) => isComptime(lhs)
    case Scoping(lhs, member) => true
    case Call(fn, args) => isComptime(fn) && args.all { arg => isComptime(arg) }
    case Block(inside, scope) => inside.all { st => isComptime(st) }
}

def emptyParserContext(): ParserContext = ParserContext(None(), 0, map::empty[String, FunctionSignature](box strOrder), map::empty[String, VariableSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))

def parser_report[T] { prog: () => T / {ParserError, InternalError} }: T / {InternalError, CompilerContextRequest} = {
    try { prog() }
    with ParserError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[PARSER ERROR] "++do getWorkingFile()++" at "++show(pos)++": "++msg)
        // println("        "++msg)
        println("\n        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        exit(1)
    }}
}

def contextHandler[T](_context: ParserContext) { prog: () => T / ParserContextRequest }: T / {TokenRequest, CompilerContextRequest, ParserError} = {
    var context = _context

    def _getVar(name: QualifiedName): VariableSignature / {ParserError, CompilerContextRequest} = name.mod match {
        case Some(modname) => (do getVariableSignature(modname, name.name)) match {
            case Some(sign) => sign
            case None() => do ParserError("Given variable '"++name.show++"' doesn't exists in the given module '"++modname++"'.", (do previous()).position)
        }
        case None() => (do getVariableSignature(do getWorkingModule(), name.name)) match {
            case Some(sign) => sign
            case None() => {
                val v = context.variables.get(name.name)
                v match {
                    case Some(sign) => sign 
                    case None() => context.parent match {
                        case Some(parent) => {
                            with contextHandler(parent);
                            do getVar(name)
                        }
                        case  _ => do ParserError("Given variable '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
    }

    def _getFunction(name: QualifiedName): FunctionSignature / {ParserError, CompilerContextRequest} = name.mod match {
        case Some(modname) => (do getFunctionSignature(modname, name.name)) match {
            case Some(sign) => sign
            case None() => do ParserError("Given function '"++name.show++"' doesn't exists in the given module '"++modname++"'.", (do previous()).position)
        }
        case None() => (do getFunctionSignature(do getWorkingModule(), name.name)) match {
            case Some(sign) => sign
            case None() => {
                val v = context.functions.get(name.name)
                v match {
                    case Some(sign) => sign 
                    case None() => context.parent match {
                        case Some(parent) => {
                            with contextHandler(parent);
                            do getFunction(name)
                        }
                        case  _ => do ParserError("Given function '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
    }

    def _getLayout(name: QualifiedName): LayoutSignature / {ParserError, CompilerContextRequest} = name.mod match {
        case Some(modname) => (do getLayoutSignature(modname, name.name)) match {
            case Some(sign) => sign
            case None() => do ParserError("Given layout '"++name.show++"' doesn't exists in the given module '"++modname++"'.", (do previous()).position)
        }
        case None() => (do getLayoutSignature(do getWorkingModule(), name.name)) match {
            case Some(sign) => sign
            case None() => {
                val v = context.layouts.get(name.name)
                v match {
                    case Some(sign) => sign 
                    case None() => context.parent match {
                        case Some(parent) => {
                            with contextHandler(parent);
                            do getLayout(name)
                        }
                        case  _ => do ParserError("Given layout '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
                    }
                }
            }
        }
    }

    try { prog() }
    with ParserContextRequest {
        def getVar(name) = resume { _getVar(name) }
        def getFunction(name) = resume { _getFunction(name) }
        def getLayout(name) = resume { _getLayout(name) }
        def hasVar(name) = resume {
            try { _getVar(name); true }
            with ParserError { (_, _) => false }
        } 
        def hasFunction(name) = resume {
            try { _getFunction(name); true }
            with ParserError { (_, _) => false }
        } 
        def hasLayout(name) = resume {
            try { _getLayout(name); true }
            with ParserError { (_, _) => false }
        } 
        def addVar(name, sign) = resume {
            if (context.variables.contains(name)) {
                do ParserError("Given variable '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables.put(name, sign), context.layouts)
            }
        }
        def addFunction(name, sign) = resume {
            if (context.functions.contains(name)) {
                do ParserError("Given function '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions.put(name, sign), context.variables, context.layouts)
            }
        }
        def addLayout(name, sign) = resume {
            if (context.layouts.contains(name)) {
                do ParserError("Given layout '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.functions, context.variables, context.layouts.put(name, sign))
            }
        }
        def isTopLevel() = resume(context.parent.isEmpty)
    }
}

def tokenHandler[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ParserError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))

    def next() = {
        if (tokens.isEmpty)
            do ParserError("Unexpected EOF.", previousToken.position)
        with on[MissingValue].default{ <> };

        previousToken = tokens.head
        tokens = tokens.tail
        previousToken
    }

    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def matchAny(tokensToMatch) = try {
            resume(tokensToMatch.any { t => t == tokens.head.tokenType })
        } with Exception[MissingValue] {
            def raise(_, _) = resume(false)
        }
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def checkReturnOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { next() }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            } with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected '"++token.show++"', got an unexpected EOF.", previousToken.position)
            }
        }
        def advance() = resume { next() }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

def handleTypeName(): Type / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest, InternalError} = {
    val t: Type = (do advance()).tokenType match {
        case IdentifierT() => {
            val mod = (do previous()).text
            do checkReturnOrCrash(Symbol(DoubleColon()))
            (do advance()).tokenType match {
                case TypeNameT(_) => Custom(QualifiedName(Some(mod), (do previous()).text))
                case _ => do ParserError("Expected typename.", (do previous()).position)
            }
        }
        case TypeNameT(_) => (do previous()).tokenType.toType()
        case _ => do ParserError("Expected typename.", (do previous()).position)
    }

    t match {
        case Custom(name) => if (do hasLayout(name)) { t } else { do ParserError("Couldn't resolve type '"++t.typeString++"' in this context.", (do previous()).position) }
        case _ => t
    }
}


def handleTypeNameNoCrashExceptUndefined(): Option[Type] / {TokenRequest, ParserContextRequest, CompilerContextRequest, ParserError, InternalError} = {
    try { Some(handleTypeName()) }
    with ParserError { (msg, pos) => if (msg.startsWith("Couldn't resolve type")) { do ParserError(msg, pos) } else { None() }}
}

 
// This will prepass all used files and register their Tokens and names to the CompilerContext
// also will register all symbols from all modules including module names to the CompilerContext
def _prepass(): Unit / {ParserError, TokenRequest, InternalError, ParserContextRequest, CompilerContextRequest} = {
    if (not(do check(Keyword(Preprocessor(Module()))))) {
        val token = do peek()
        do ParserError("Expected 'module' statement at the beginning of the file. Got '"++token.text++"' instead.", token.position)
    }
    do advance()
    if (not (do check(IdentifierT()))) {
        val token = do peek()
        do ParserError("Expected a module name, got '"++token.text++"' instead.", token.position)
    }
    do setWorkingModule((do advance()).text)
    do registerLexerOutput([])

__DEBUG_START__
    println("Prepassing Module: "++do getWorkingModule())
__DEBUG_END__

    var variableSignatures = map::empty[String, VariableSignature](box strOrder)
    var functionSignatures = map::empty[String, FunctionSignature](box strOrder)
    var layoutSignatures = map::empty[String, LayoutSignature](box strOrder)

    def handleVariable(public: Bool, mutable: Bool, index: Int): (String, VariableSignature) = {
        val identifier: Token = do checkReturnOrCrash(IdentifierT())
        val colon: Token = do checkReturnOrCrash(Symbol(Colon()))
        val typename: Type = handleTypeName()

        if (variableSignatures.contains(identifier.text))
            do ParserError("Multiple definition of variable '"++identifier.text++"'.", identifier.position)

        (identifier.text, VariableSignature(identifier.text, public, mutable, false, true, index, typename))
    }
    def handleLet(public: Bool): Unit = (do peek()).tokenType match {
        case Keyword(Mut()) => {
            do advance()
            val (name, signature) = handleVariable(public, true, do getGlobalStackIndex())
            variableSignatures = variableSignatures.put(name, signature)
        }
        case IdentifierT() => {
            val (name, signature) = handleVariable(public, false, do getGlobalStackIndex())
            variableSignatures = variableSignatures.put(name, signature)
        }
        case _ => do ParserError("Epected keyword 'mut' or identifier after 'let'.", (do previous()).position)
    }
    def handleLayout(public: Bool, wrapper: Bool): Unit / ParserContextRequest = {
        val name: String = (do advance()).tokenType match {
            case TypeNameT(CustomT(n)) => n
            case _ => do ParserError("Expected a custom typename, got '"++(do previous()).text++"' instead.", (do previous()).position)
        }

        if (layoutSignatures.contains(name))
            do ParserError("Multiple definition of layout '"++name++"'.", (do previous()).position)

        val pos: Position = (do previous()).position
        
        do checkReturnOrCrash(Symbol(LBrace()))
        var innerIndex: Int = 0
        var layout: List[VariableSignature] = []
        while ((do peek()).tokenType != Symbol(RBrace())) {
            var pos: Position = Position(0, 0, 0)
            val (_, signature) = (do peek()).tokenType match {
                case Keyword(Pub()) => {
                    if (wrapper)
                        do ParserError("Public fields in wrapper layouts are not allowed.", (do peek()).position)
                    do advance()
                    (do peek()).tokenType match {
                        case Keyword(Mut()) => {
                            do advance()
                            pos = (do peek()).position
                            handleVariable(true, true, innerIndex)
                        }
                        case _ => {
                            pos = (do peek()).position
                            handleVariable(true, false, innerIndex)
                        }
                    }
                }
                case Keyword(Mut()) => {
                    do advance()
                    pos = (do peek()).position
                    handleVariable(false, true, innerIndex)
                }
                case _ => {
                    pos = (do peek()).position
                    handleVariable(false, false, innerIndex)
                }
            }
            if (layout.any { s => s.name == signature.name })
                do ParserError("Multiple definitions of field '"++signature.name++"' in layout '"++name++"'.", pos)
            do checkReturnOrCrash(Symbol(Semicolon()))
            layout = Cons(signature, layout)
            innerIndex = innerIndex + signature.varType.typeSize()
        }

        if (layout.isEmpty)
            do ParserError("Empty layouts are not supported.", pos)

        do advance()

        layoutSignatures = layoutSignatures.put(name, LayoutSignature(name, public, wrapper, layout.reverse))
    }
    def handleWrapper(public: Bool): Unit / ParserContextRequest = {
        do checkReturnOrCrash(Keyword(Layout()))
        handleLayout(public, true)
    }
    def handleFunction(public: Bool): Unit = {
        var name: String = ""
        val typename: Option[Type] = handleTypeNameNoCrashExceptUndefined()
        if (typename is Some(_)) {
            val _ = do checkReturnOrCrash(Symbol(DoubleColon()))
            val _ = do advance()
        }

        name = (do previous()).text
        // if (typename is Some(t))
        //  name = t.typeString()++"::"++(do previous()).text
        // preventing name collisions

        if (functionSignatures.contains(name))
            do ParserError("Multiple definition of function '"++name++"'.", (do previous()).position)

        do checkReturnOrCrash(Symbol(LParen()))

        var stackIndexArgs: Int = 0 
        var arguments: List[VariableSignature] = typename match {
            case Some(t) => {
                stackIndexArgs = 4
                [ VariableSignature("this", false, false, false, false, 0, t) ]
            }
            case None() => []
        }
        var bodyOn: Bool = true
        while (bodyOn) {
            if ((do peek()).tokenType != Symbol(RParen()))
            {
                val (_, signature) = handleVariable(false, false, stackIndexArgs)
                arguments = Cons(signature, arguments)

                (do advance()).tokenType match {
                    case Symbol(RParen()) => bodyOn = false
                    case Symbol(Comma()) => ()
                    case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                }

                stackIndexArgs = stackIndexArgs + signature.varType.typeSize()
            } else {
                bodyOn = false
                val _ = do advance()
            }
        }

        do checkReturnOrCrash(Symbol(Arrow()))

        var returns: List[Type] = []
        bodyOn = true
        (do advance()).tokenType match {
            case IdentifierT() => {
                val mod: String = (do previous()).text
                do checkReturnOrCrash(Symbol(DoubleColon()))
                (do advance()).tokenType match {
                    case TypeNameT(CustomT(name)) => returns = Cons(Custom(QualifiedName(Some(mod), name)), returns)
                    case _ => do ParserError("Expected a custom type name.", (do previous()).position)
                }
            }
            case TypeNameT(typename) =>
                returns = Cons(typename.toType(), returns)
            case Symbol(LParen()) => {
                while (bodyOn) (do advance()).tokenType match {
                    case IdentifierT() => {
                        val mod: String = (do previous()).text
                        do checkReturnOrCrash(Symbol(DoubleColon()))
                        (do advance()).tokenType match {
                            case TypeNameT(CustomT(name)) => returns = Cons(Custom(QualifiedName(Some(mod), name)), returns)
                            case _ => do ParserError("Expected a custom type name.", (do previous()).position)
                        }
                        (do advance()).tokenType match {
                            case Symbol(RParen()) => bodyOn = false
                            case Symbol(Comma()) => ()
                            case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                        }
                    }
                    case TypeNameT(typename) => {
                        returns = Cons(typename.toType(), returns)
                        (do advance()).tokenType match {
                            case Symbol(RParen()) => bodyOn = false
                            case Symbol(Comma()) => ()
                            case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                        }
                    }
                    case _ => do ParserError("Expected type name, got '"++(do previous()).text++"' instead.", (do previous()).position)
                }
            }
            case _ => do ParserError("Expected return type(s), got '"++(do previous()).text++"'. instead", (do previous()).position)
        }

        val pos: Position = (do checkReturnOrCrash(Symbol(LBrace()))).position
        var ident: Int = 1
        while (not(do is_eof()) && ident > 0) (do advance()).tokenType match {
            case Symbol(RBrace()) => ident = ident - 1
            case Symbol(LBrace()) => ident = ident + 1
            case Keyword(Layout()) => do ParserError("Layout definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Wrapper()) => do ParserError("Wrapper definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Pub()) => do ParserError("Public identifiers in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Fn()) => do ParserError("Function definitions in non top-level contexts are not permitted.", (do previous()).position)
            case _ => ()
        }
        if (do is_eof())
            do ParserError("Unterminated function body.", pos)

        functionSignatures = functionSignatures.put(name, FunctionSignature(name, public, false, typename, arguments.reverse, returns))
    }

    while (not(do is_eof()))
    {
        val token = do advance()

        token.tokenType match {
            case Keyword(Preprocessor(Module())) => do ParserError("A source file can only include one module directive.", token.position)
            case Keyword(Preprocessor(Include())) => {
                val token: Token = do advance()
                if (token.tokenType != LiteralT(StringT())) {
                    do ParserError("Expected a file path, got '"++token.text++"' instead.", token.position)
                }

                if (not (do checkDependency(token.text)))
                {
                    val currentFile: String = do getWorkingFile()
                    val currentModule: String = do getWorkingModule()
                    do setWorkingFile(token.text)
                    val tokenized: List[Token] = lexer::lex()

                    with parser_report;
                    with tokenHandler(tokenized);
                    with contextHandler(emptyParserContext());

                    tokenHandler(tokenized) {
                        _prepass()
                    }

__DEBUG_START__
                    println("Registering Lexer Output: "++do getWorkingFile())
__DEBUG_END__
                    do registerLexerOutput(tokenized)
                    
                    do setWorkingFile(currentFile)
                    do setWorkingModule(currentModule)
                } else { () }
            }
            case Keyword(Pub()) => do advance().tokenType match {
                case Keyword(Let()) => handleLet(true)
                case Keyword(Wrapper()) => handleWrapper(true)
                case Keyword(Layout()) => handleLayout(true, false)
                case Keyword(Fn()) => handleFunction(true)
                case _ => do ParserError("Unexpected token in top-level definition. Expected one of 'let, wrapper, layout, fn'.", (do previous()).position)
            }
            case Keyword(Fn()) => handleFunction(false)
            case Keyword(Let()) => handleLet(false)
            case Keyword(Wrapper()) => handleWrapper(false)
            case Keyword(Layout()) => handleLayout(false, false)
            case _ => {}
        }
    }

    do updateModule(variableSignatures, functionSignatures, layoutSignatures)
}

def prepass(tokens: List[Token]): Unit / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext())

    tokenHandler(tokens) { // needs a separate handler since it eats
        _prepass()
    }

__DEBUG_START__
    println("Registering Lexer Output: "++do getWorkingModule())
__DEBUG_END__

    do registerLexerOutput(tokens)
}

def parseEquality(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    AST(do getWorkingModule(), [])
}

def parseExpressionStatement(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseVariableDefinition(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseConditional(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseWhileStatement(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseFnDefinition(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseFnDefinition(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseReturnStmt(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parseAssignment(): AST / {ParserContextRequest, ParserError, TokenRequest, InternalError, CompilerContextRequest} = {
    unimplemented(__FILE__, __LINE__)
}

def parse(tokens: List[Token]): AST / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext());
    with on[MissingValue].panic;

    // All top-level checks and checks for non top-level definitions are handled
    // in prepass already as well as 'module' and 'include' directives.
    while (not(do is_eof())) (do advance()).tokenType match {
        case Keyword(Preprocessor(_)) => { val _ = do advance() }
        case Keyword(Wrapper()) => while ((do advance()).tokenType != Symbol(RBrace())) { }
        case Keyword(Layout()) => while ((do advance()).tokenType != Symbol(RBrace())) { }
        case Keyword(Pub()) =>
            if (not(do isTopLevel())) {
                do ParserError("Public identifiers in non top-level contexts are not enabled.", (do previous()).position)
            } else {
                unimplemented(__FILE__, __LINE__)
            }
        //case Keyword(Let()) => handleVariableDefinition()
        case _ => do ParserError("Unexpected token '"++(do previous()).text++"', expected statement.", (do previous()).position)
    }

    AST("", [])
}

/*
    JASL EBNF OF EXPRESSIONS

    <expression> ::= <conditional-expression>
    <conditional-expression> ::= <logical-or-expression>
    <logical-or-expression> ::= <logical-and-expression> { "||" <logical-and-expression> }
    <logical-and-expression> ::= <equality-expression> { "&&" <equality-expression> }
    <equality-expression> ::= <relational-expression> { ( "==" | "!=" ) <relational-expression> }
    <relational-expression> ::= <additive-expression> { ( ">" | "<" | ">=" | "<=" ) <additive-expression> }
    <additive-expression> ::= <multiplicative-expression> { ( "+" | "-" ) <multiplicative-expression> }
    <multiplicative-expression> ::= <unary-expression> { ( "*" | "/" ) <unary-expression> }
    <unary-expression> ::= ( "-" | "!" | "not" ) <unary-expression> | <postfix-expression>
    <postfix-expression> ::= <primary-expression> { <postfix-suffix> }
    <postfix-suffix> ::= "." <identifier> | "(" [ <arg-list> ] ")" | "::" <identifier>
    <arg-list> ::= <expression> { "," <expression> }
    <primary-expression> ::= <identifier> | <literal> | "(" <expression> ")" | <block-expression>
    <block-expression> ::= "{" { <statement> } "}"
*/
