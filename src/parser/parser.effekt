module parser

import map
import process
import io/filesystem

import lexer/lexer
import context/context

interface ParserContextRequest {
    def getVar(name: QualifiedName): VariableSignature / {ParserError, CompilerContextRequest}
    def hasVar(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def hasFunction(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def hasLayout(name: QualifiedName): Bool / {ParserError, CompilerContextRequest}
    def addVar(name: String, sign: VariableSignature): Unit / {ParserError, CompilerContextRequest}
    def isTopLevel(): Bool
    def createChildContext(): ParserContext
    def getCurrentContext(): ParserContext
}

interface TokenRequest {
    def matchNext(tokensToMatch: List[TokenType]): Bool // match the tokens starting from the current one
    def matchAny(tokensToMatch: List[TokenType]): Bool // match the next token to either of given ones
    def check(token: TokenType): Bool // check the current token
    def checkOrCrash(token: TokenType): Bool / ParserError
    def checkReturnOrCrash(token: TokenType): Token / ParserError
    def advance(): Token / ParserError
    def peek(): Token
    def previous(): Token
    def is_eof(): Bool
}

effect ParserError(msg: String, pos: Position): Nothing / CompilerContextRequest

def typeSize(l: LayoutSignature): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = l.fields.map{ v => v.varType.typeSize() }.sum()

def typeSize(t: Type): Int / {ParserError, ParserContextRequest, CompilerContextRequest, TokenRequest} = t match {
    case Type::Bool() => 1
    case Type::UInt() => 4
    case Type::Int() => 4
    case Type::Float() => 4
    case Type::UByte() => 1
    case Type::Byte() => 1
    case Type::Pointer(_) => 4
    case Type::Void() => 0
    case Type::Custom(name) => (do getLayoutSignature(name)) match {
        case Some(signature) => signature.typeSize()
        case None() => do ParserError("Given layout '"++name.show++"' couldn't be found in this context.", (do previous()).position)
    }
    case Type::FunctionPointer(_, _) => 4
}

def foreachTypeList(list: List[Type]) { act: Type => Unit / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} }: Unit / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = list match {
    case Cons(x, xs) => {
        act(x)
        foreachTypeList(xs){act}
    }
    case Nil() => ()
}

def show(t: Type): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = t match {
    case Type::Bool() => "bool"
    case Type::UInt() => "u32"
    case Type::Int() => "i32"
    case Type::Float() => "float"
    case Type::UByte() => "u8"
    case Type::Byte() => "i8"
    case Type::Pointer(ptrType) => show(ptrType)++"*"
    case Type::Void() => "void"
    case Type::Custom(QualifiedName(Some(mod), name)) => mod++"::"++name
    case Type::Custom(QualifiedName(None(), name)) => name
    case Type::FunctionPointer(args, returns) => {
        var str: String = "fn ("
        var l: Int = args.size
        var i: Int = 0
        args.foreachTypeList { t => {
            str = str++t.show
            if (i != (l - 1))
                str = str++", "
            i = i + 1
        }}
        str = str++") -> ("
        l = returns.size
        i = 0
        returns.foreachTypeList  { t => {
            str = str++t.show
            if (i != (l - 1))
                str = str++", "
            i = i + 1
        }}
        str = str++")"
        str
    }
}

def typeString(t: Type): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = t.show()
def typeString(dt: DataType): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = dt.toType().typeString()

__DEBUG_START__
def show(v: VariableSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++v.varType.typeSize().show()++"]["++v.stackIndex.show()++"] "
    if (v.comptime) str = "comptime "
    if (v.public) str = str++"pub "
    // str = str++"let "
    if (v.mutable) str = str++"mut "
    str++v.name++": "++v.varType.typeString().show()
}

def show(f: FunctionSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = ""
    if (f.comptime) str = "comptime "
    if (f.public) str = str++"pub "
    str = str++"fn "++f.name++"("
    var l: Int = f.arguments.size
    f.arguments.foreachIndex { (i, v) => {
        //str = str++v.name++": "++v.varType.typeString()
        str = str++v.show
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++") -> ("
    l = f.returns.size
    f.returns.foreachIndex { (i, t) => {
        str = str++t.typeString()
        if (i != (l - 1))
            str = str++", "
    }}
    str = str++")"
    if (f.ofType is Some(t)) str = str++" of type "++t.typeString()
    str
}

def show(l: LayoutSignature): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "["++l.typeSize().show()++"]"
    if (l.public) str = "pub "
    if (l.wrapper) str = str++"wrapper "
    str = str++l.name++" { "
    l.fields.foreach { v => {
        str = str++v.show
        /*
            if (v.public) str = str++"pub "
            if (v.mutable) str = str++"mut "
            str = str++v.name++": "++v.varType.typeString()++"; "
        */
    }}
    str++" }"
}
__DEBUG_END__

def isComptime(stmt: Statement): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = stmt match {
    case ExpressionStatement(expr, _) => expr.isComptime
    case VariableDefinition(signature, initializer, _) => if (initializer is Some(expr)) { isComptime(expr) } else { true }
    case Conditional(condition, body, scope, fallback, _) => isComptime(condition) && isComptime(body) && (if (fallback is Some(else_block)) { isComptime(else_block) } else { true })
    case WhileStmt(condition, body, scope, _) => false // No.
    case FnDefinition(signature, body, scope) => signature.comptime
    // case LayoutDeclaration(signature, _) => true // Come on.
    case ReturnStmt(returns, _) => returns.all { r => isComptime(r) }
    case Assignment(lhs, rhs, _) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: BinaryOp): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Addition(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Subtraction(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Division(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Multiplication(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Equality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Inequality(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Great(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Lesser(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case GreaterEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case LesserEqual(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case And(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
    case Or(lhs, rhs) => isComptime(lhs) && isComptime(rhs)
}

def isComptime(op: UnaryOp): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = op match {
    case Negation(rhs) => isComptime(rhs)
    case Not(rhs) => isComptime(rhs)
}

def isComptime(expr: Expression): Bool / {InternalError, ParserContextRequest, ParserError, TokenRequest, CompilerContextRequest} = expr match {
    case Initialization(_, initializers) => initializers.all { init => init.isComptime }
    case Identifier(name) =>
        if (do hasVar(name)) { (do getVar(name)).comptime }
        else if (do hasFunction(name)) {
            (do getFunctionSignature(name)) match {
                case Some(signature) => signature.comptime
                case None() => {
                    do ParserError("Couldn't find given function '"++name.show++"' in this context.", (do previous()).position)
                    unreachable(__FILE__, __LINE__)
                }
            }
        }
        else do ParserError("Couldn't find any variable or function with name '"++name.show++"' in this context.", (do previous()).position)
    case Binary(binOp) => isComptime(binOp)
    case Unary(unOp) => isComptime(unOp)
    case Grouping(expr) => isComptime(expr)
    case Literal(value) => true
    case Dot(lhs, member) => isComptime(lhs)
    case Scoping(lhs, member) => true
    case Call(fn, args) => isComptime(fn) && args.all { arg => isComptime(arg) }
    case Block(inside, scope) => inside.all { st => isComptime(st) }
}

def emptyParserContext(): ParserContext =
    // ParserContext(None(), 0, map::empty[String, FunctionSignature](box strOrder), map::empty[String, VariableSignature](box strOrder), map::empty[String, LayoutSignature](box strOrder))
    ParserContext(None(), 0, map::empty[String, VariableSignature](box strOrder))

def parser_report[T] { prog: () => T / {ParserError, InternalError} }: T / {InternalError, CompilerContextRequest} = {
    try { prog() }
    with ParserError { (msg, pos) => {
        val source = openRead(do getWorkingFile())
        val errLine: String = try {
                                val line = pos.line - 1
                                val lines = source.split("\n")
                                lines.get(line)
                            } with Exception[OutOfBounds] {
                                def raise(_, _) = "<unknown>"
                            }

        val spaces: String = " ".repeat(pos.col+7)
        val helpLine: String = getHelpLine()

        println("[PARSER ERROR] "++do getWorkingFile()++" at "++show(pos)++": "++msg)
        println("\n        "++errLine)
        println(spaces++"^")
        println(spaces++helpLine)
        exit(1)
    }}
}

def contextHandler[T](_context: ParserContext) { prog: () => T / ParserContextRequest }: T / {TokenRequest, CompilerContextRequest, ParserError} = {
    var context = _context
    var stackIndex: Int = 0

    def _getVar(name: QualifiedName): VariableSignature / {ParserError, CompilerContextRequest} = do getVariableSignature(name) match {
        case Some(signature) => signature
        case None() => {
            val v = context.variables.get(name.name)
            v match {
                case Some(sign) => sign 
                case None() => context.parent match {
                    case Some(parent) => {
                        with contextHandler(parent);
                        do getVar(name)
                    }
                    case  _ => do ParserError("Given variable '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
                }
            }
        }
    }

    def _getFunction(name: QualifiedName): FunctionSignature / {ParserError, CompilerContextRequest} = do getFunctionSignature(name) match {
        case Some(sign) => sign
        case None() => do ParserError("Given function '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
    }

    def _getLayout(name: QualifiedName): LayoutSignature / {ParserError, CompilerContextRequest} = do getLayoutSignature(name) match {
        case Some(sign) => sign
        case None() => do ParserError("Given layout '"++name.show++"' doesn't exists in the current context.", (do previous()).position)
    }

    try { prog() }
    with ParserContextRequest {
        def getVar(name) = resume { _getVar(name) }
        def hasVar(name) = resume {
            try { _getVar(name); true }
            with ParserError { (_, _) => false }
        } 
        def hasFunction(name) = resume {
            try { _getFunction(name); true }
            with ParserError { (_, _) => false }
        } 
        def hasLayout(name) = resume {
            try { _getLayout(name); true }
            with ParserError { (_, _) => false }
        } 
        def addVar(name, sign) = resume {
            if (context.variables.contains(name)) {
                do ParserError("Given variable '"++name++"' already exists in the current context.", (do previous()).position)
            } else {
                context = ParserContext(context.parent, context.stackIndex, context.variables.put(name, sign))
                with contextHandler(context);
                stackIndex = stackIndex + sign.varType.typeSize
            }
        }
        def isTopLevel() = resume(context.parent.isEmpty)
        def createChildContext() = resume(ParserContext(Some(context), context.stackIndex + stackIndex, map::empty[String, VariableSignature](box strOrder)))
        def getCurrentContext() = resume(context)
    }
}

def tokenHandler[T](_tokens: List[Token]){ prog: () => T / TokenRequest }: T / {ParserError, CompilerContextRequest} = {
    var tokens = _tokens
    var previousToken: Token = Token(EOF(), "", Position(0, 0, 0))

    def next() = {
        if (tokens.isEmpty)
            do ParserError("Unexpected EOF.", previousToken.position)
        with on[MissingValue].default{ <> };

        previousToken = tokens.head
        tokens = tokens.tail
        previousToken
    }

    try { prog() }
    with TokenRequest {
        def matchNext(tokensToMatch) = resume(compare(tokensToMatch, tokens.take(tokensToMatch.size).map{t => t.tokenType}){ (l, r) => infixEq(l, r) })
        def matchAny(tokensToMatch) = try {
            resume(tokensToMatch.any { t => t == tokens.head.tokenType })
        } with Exception[MissingValue] {
            def raise(_, _) = resume(false)
        }
        def check(token) = resume(try { token.infixEq(tokens.head.tokenType) }
                            with Exception[MissingValue] {
                                def raise(_, _) = false
                            })
        def checkOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { true }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            }
            with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected `"++token.show++"', got  EOF.", previousToken.position)
            }
        }
        def checkReturnOrCrash(token) = resume {
            try {
                if (token.infixEq(tokens.head.tokenType)) { next() }
                else do ParserError("Expected '"++token.show++"', got '"++tokens.head.tokenType.show++"'.", tokens.head.position)
            } with Exception[MissingValue] {
                def raise(_, _) = do ParserError("Expected '"++token.show++"', got an unexpected EOF.", previousToken.position)
            }
        }
        def advance() = resume { next() }
        def peek() = resume(try { tokens.head }
                            with Exception[MissingValue] {
                                def raise(_, _) = previousToken
                            })
        def previous() = resume(previousToken)
        def is_eof() = resume(tokens.isEmpty)
    }
}

def handleTypeName(): Type / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest, InternalError} = {
    val t: Type = (do advance()).tokenType match {
        case IdentifierT() => {
            val mod = (do previous()).text
            do checkReturnOrCrash(Symbol(DoubleColon()))
            (do advance()).tokenType match {
                case TypeNameT(_) => Custom(QualifiedName(Some(mod), (do previous()).text))
                case _ => do ParserError("Expected typename.", (do previous()).position)
            }
        }
        case TypeNameT(_) => (do previous()).tokenType.toType()
        case Keyword(Fn()) => {
            // fn (params) -> returns
            do checkReturnOrCrash(Symbol(LParen()))

            var arguments: List[Type] = []
            var bodyOn: Bool = true
            while (bodyOn) {
                if ((do peek()).tokenType != Symbol(RParen()))
                {
                    val pos: Position = (do peek()).position
                    val typename = handleTypeName()
                    arguments = Cons(typename, arguments)

                    (do advance()).tokenType match {
                        case Symbol(RParen()) => bodyOn = false
                        case Symbol(Comma()) => ()
                        case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                    }
                } else {
                    bodyOn = false
                    val _ = do advance()
                }
            }

            do checkReturnOrCrash(Symbol(Arrow()))

            var returns: List[Type] = []
            bodyOn = true
            (do peek()).tokenType match {
                case Symbol(LParen()) => {
                    do advance()
                    while (bodyOn) (do peek()).tokenType match {
                        case Symbol(RParen()) => {
                            do advance()
                            bodyOn = false
                        }
                        case _ => {
                            val t: Type = handleTypeName()
                            returns = Cons(t, returns)
                            (do peek()).tokenType match {
                                case Symbol(RParen()) => ()
                                case Symbol(Comma()) => { val _ = do advance() } 
                                case _ => do ParserError("Unexpected token '"++(do peek()).text++"' in function signature.", (do peek()).position)
                            }
                        }
                    }
                }
                case _ => {
                    val t: Type = handleTypeName()
                    returns = Cons(t, returns)
                }
            }
            FunctionPointer(arguments.reverse, returns.reverse)
        }
        case _ => do ParserError("Expected typename.", (do previous()).position)
    }

    t match {
        case Custom(name) => if (do hasLayout(name)) { t }
                             else name.mod match { 
                                case Some(modname) => do ParserError("Couldn't resolve type '"++name.name++"' in module '"++modname++"'.", (do previous()).position)
                                case None() => do ParserError("Couldn't resolve type '"++t.typeString++"' in module in this context.", (do previous()).position)
                             }
        case _ => t
    }
}


def handleTypeNameNoCrashExceptUndefined(): Option[Type] / {TokenRequest, ParserContextRequest, CompilerContextRequest, ParserError, InternalError} = {
    try { Some(handleTypeName()) }
    with ParserError { (msg, pos) => if (msg.startsWith("Couldn't resolve type")) { do ParserError(msg, pos) } else { None() }}
}

 
// This will prepass all used files and register their Tokens and names to the CompilerContext
// also will register all symbols from all modules including module names to the CompilerContext
def _prepass(): Unit / {ParserError, TokenRequest, InternalError, ParserContextRequest, CompilerContextRequest} = {
    if (not(do check(Keyword(Preprocessor(Module()))))) {
        val token = do peek()
        do ParserError("Expected 'module' statement at the beginning of the file. Got '"++token.text++"' instead.", token.position)
    }
    do advance()
    if (not (do check(IdentifierT()))) {
        val token = do peek()
        do ParserError("Expected a module name, got '"++token.text++"' instead.", token.position)
    }
    do setWorkingModule((do advance()).text)
    do registerLexerOutput([])

__DEBUG_START__
    println("Prepassing Module: "++do getWorkingModule())
__DEBUG_END__

    var variableSignatures = map::empty[String, VariableSignature](box strOrder)
    var functionSignatures = map::empty[String, FunctionSignature](box strOrder)
    var layoutSignatures = map::empty[String, LayoutSignature](box strOrder)

    def handleVariable(public: Bool, mutable: Bool, index: Int): (String, VariableSignature) = {
        val identifier: Token = do checkReturnOrCrash(IdentifierT())
        val colon: Token = do checkReturnOrCrash(Symbol(Colon()))
        val typename: Type = handleTypeName()

        if (variableSignatures.contains(identifier.text))
            do ParserError("Multiple definition of variable '"++identifier.text++"'.", identifier.position)

        (identifier.text, VariableSignature(identifier.text, public, mutable, false, true, index, typename))
    }
    def handleLet(public: Bool): Unit = (do peek()).tokenType match {
        case Keyword(Mut()) => {
            do advance()
            val (name, signature) = handleVariable(public, true, do getGlobalStackIndex())
            variableSignatures = variableSignatures.put(name, signature)
        }
        case IdentifierT() => {
            val (name, signature) = handleVariable(public, false, do getGlobalStackIndex())
            variableSignatures = variableSignatures.put(name, signature)
        }
        case _ => do ParserError("Epected keyword 'mut' or identifier after 'let'.", (do previous()).position)
    }
    def handleLayout(public: Bool, wrapper: Bool): Unit / ParserContextRequest = {
        val name: String = (do advance()).tokenType match {
            case TypeNameT(CustomT(n)) => n
            case _ => do ParserError("Expected a custom typename, got '"++(do previous()).text++"' instead.", (do previous()).position)
        }

        if (layoutSignatures.contains(name))
            do ParserError("Multiple definition of layout '"++name++"'.", (do previous()).position)

        val pos: Position = (do previous()).position
        
        do checkReturnOrCrash(Symbol(LBrace()))
        var innerIndex: Int = 0
        var layout: List[VariableSignature] = []
        while ((do peek()).tokenType != Symbol(RBrace())) {
            var pos: Position = Position(0, 0, 0)
            val (_, signature) = (do peek()).tokenType match {
                case Keyword(Pub()) => {
                    if (wrapper)
                        do ParserError("Public fields in wrapper layouts are not allowed.", (do peek()).position)
                    do advance()
                    (do peek()).tokenType match {
                        case Keyword(Mut()) => {
                            do advance()
                            pos = (do peek()).position
                            handleVariable(true, true, innerIndex)
                        }
                        case _ => {
                            pos = (do peek()).position
                            handleVariable(true, false, innerIndex)
                        }
                    }
                }
                case Keyword(Mut()) => {
                    do advance()
                    pos = (do peek()).position
                    handleVariable(false, true, innerIndex)
                }
                case _ => {
                    pos = (do peek()).position
                    handleVariable(false, false, innerIndex)
                }
            }
            if (layout.any { s => s.name == signature.name })
                do ParserError("Multiple definitions of field '"++signature.name++"' in layout '"++name++"'.", pos)
            do checkReturnOrCrash(Symbol(Semicolon()))
            layout = Cons(signature, layout)
            innerIndex = innerIndex + signature.varType.typeSize()
        }

        if (layout.isEmpty)
            do ParserError("Empty layouts are not supported.", pos)

        do advance()

        layoutSignatures = layoutSignatures.put(name, LayoutSignature(name, public, wrapper, layout.reverse))
    }
    def handleWrapper(public: Bool): Unit / ParserContextRequest = {
        do checkReturnOrCrash(Keyword(Layout()))
        handleLayout(public, true)
    }
    def handleFunction(public: Bool): Unit = {
        var name: String = ""
        val typename: Option[Type] = handleTypeNameNoCrashExceptUndefined()
        if (typename is Some(_)) {
            val _ = do checkReturnOrCrash(Symbol(DoubleColon()))
            val _ = do advance()
        }

        name = (do previous()).text

        if (functionSignatures.contains(name))
            do ParserError("Multiple definition of function '"++name++"'.", (do previous()).position)

        do checkReturnOrCrash(Symbol(LParen()))

        var stackIndexArgs: Int = 0 
        var arguments: List[VariableSignature] = typename match {
            case Some(t) => {
                stackIndexArgs = 4
                [ VariableSignature("this", false, false, false, false, 0, t) ]
            }
            case None() => []
        }
        var bodyOn: Bool = true
        while (bodyOn) {
            if ((do peek()).tokenType != Symbol(RParen()))
            {
                val pos: Position = (do peek()).position
                val (_, signature) = handleVariable(false, false, stackIndexArgs)
                if (arguments.any { v => v.name == signature.name })
                    do ParserError("Multiple definitions of argument '"++signature.name++"' in function '"++name.show++"'.", pos)
                arguments = Cons(signature, arguments)

                (do advance()).tokenType match {
                    case Symbol(RParen()) => bodyOn = false
                    case Symbol(Comma()) => ()
                    case _ => do ParserError("Unexpected token '"++(do previous()).text++"' in function signature.", (do previous()).position)
                }

                stackIndexArgs = stackIndexArgs + signature.varType.typeSize()
            } else {
                bodyOn = false
                val _ = do advance()
            }
        }

        do checkReturnOrCrash(Symbol(Arrow()))

        var returns: List[Type] = []
        bodyOn = true
        (do peek()).tokenType match {
            case Symbol(LParen()) => {
                do advance()
                while (bodyOn) (do peek()).tokenType match {
                    case Symbol(RParen()) => {
                        do advance()
                        bodyOn = false
                    }
                    case _ => {
                        val t: Type = handleTypeName()
                        returns = Cons(t, returns)
                        (do peek()).tokenType match {
                            case Symbol(RParen()) => ()
                            case Symbol(Comma()) => { val _ = do advance() } 
                            case _ => do ParserError("Unexpected token '"++(do peek()).text++"' in function signature.", (do peek()).position)
                        }
                    }
                }
            }
            case _ => {
                val t: Type = handleTypeName()
                returns = Cons(t, returns)
            }
        }

        val pos: Position = (do checkReturnOrCrash(Symbol(LBrace()))).position
        var ident: Int = 1
        while (not(do is_eof()) && ident > 0) (do advance()).tokenType match {
            case Symbol(RBrace()) => ident = ident - 1
            case Symbol(LBrace()) => ident = ident + 1
            case Keyword(Layout()) => do ParserError("Layout definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Wrapper()) => do ParserError("Wrapper definitions in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Pub()) => do ParserError("Public identifiers in non top-level contexts are not permitted.", (do previous()).position)
            case Keyword(Fn()) => do ParserError("Function definitions in non top-level contexts are not permitted.", (do previous()).position)
            case _ => ()
        }
        if (do is_eof())
            do ParserError("Unterminated function body.", pos)

        functionSignatures = functionSignatures.put(name, FunctionSignature(name, public, false, typename, arguments.reverse, returns.reverse))
    }

    while (not(do is_eof()))
    {
        val token = do advance()

        token.tokenType match {
            case Keyword(Preprocessor(Module())) => do ParserError("A source file can only include one module directive.", token.position)
            case Keyword(Preprocessor(Include())) => {
                val token: Token = do advance()
                if (token.tokenType != LiteralT(StringT())) {
                    do ParserError("Expected a file path, got '"++token.text++"' instead.", token.position)
                }

                if (not (do checkDependency(token.text)))
                {
                    val currentFile: String = do getWorkingFile()
                    val currentModule: String = do getWorkingModule()
                    do setWorkingFile(token.text)
                    val tokenized: List[Token] = lexer::lex()

                    with parser_report;
                    with tokenHandler(tokenized);
                    with contextHandler(emptyParserContext());

                    tokenHandler(tokenized) {
                        _prepass()
                    }

__DEBUG_START__
                    println("Registering Lexer Output: "++do getWorkingFile())
__DEBUG_END__
                    do registerLexerOutput(tokenized)
                    
                    do setWorkingFile(currentFile)
                    do setWorkingModule(currentModule)
                } else { () }
            }
            case Keyword(Pub()) => do advance().tokenType match {
                case Keyword(Let()) => handleLet(true)
                case Keyword(Wrapper()) => handleWrapper(true)
                case Keyword(Layout()) => handleLayout(true, false)
                case Keyword(Fn()) => handleFunction(true)
                case _ => do ParserError("Unexpected token in top-level definition. Expected one of 'let, wrapper, layout, fn'.", (do previous()).position)
            }
            case Keyword(Fn()) => handleFunction(false)
            case Keyword(Let()) => handleLet(false)
            case Keyword(Wrapper()) => handleWrapper(false)
            case Keyword(Layout()) => handleLayout(false, false)
            case _ => {}
        }
    }

    do updateModule(variableSignatures, functionSignatures, layoutSignatures)
}

def prepass(tokens: List[Token]): Unit / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext())

    tokenHandler(tokens) { // needs a separate handler since it eats
        _prepass()
    }

__DEBUG_START__
    println("Registering Lexer Output: "++do getWorkingModule())
__DEBUG_END__

    do registerLexerOutput(tokens)
}

interface ReturnTypeRegister {
    def returns(returnTypes: List[Type]): Unit / {ParserError, TokenRequest}
}

def show(returnList: List[Type]): String / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    var str: String = "("
    val l: Int = returnList.size
    var i: Int = 0
    returnList.foreachTypeList  { t => {
        str = str++t.show
        if (i != (l - 1))
            str = str++", "
        i = i + 1
    }}
    str++")"
}

def returnHandler[T](expected: List[Type]) { prog: () => T / ReturnTypeRegister }: T / {ParserError, TokenRequest, CompilerContextRequest, ParserContextRequest} = {
    try { prog() }
    with ReturnTypeRegister {
        def returns(returnTypes) = resume { 
            if (expected.compare(returnTypes){(l, r) => l == r}){
                do ParserError("Missmatching return types. Type '"++returnTypes.show++"' is not allowed in this context, '"++expected.show++"' is expected.", (do previous()).position)
            } else ()
        }
    }
}

def parseBlockExpression(): Expression / {TokenRequest, ParserError, ParserContextRequest, CompilerContextRequest} = {
    with contextHandler(do createChildContext());
    // TODO: Continue from here.
    // placeholder to skip the block
    while ((do advance()).tokenType != Symbol(RBrace())) { }
    Block([], do getCurrentContext())
}

def parse(tokens: List[Token]): AST / {InternalError, CompilerContextRequest} = {
    with parser_report;
    with tokenHandler(tokens);
    with contextHandler(emptyParserContext());
    with on[MissingValue].panic;

    def handleFunctionDef(): Statement = {
        // non-top level checks are already done by prepass
        handleTypeNameNoCrashExceptUndefined()
        val name: String = (do previous()).text
        val signature: FunctionSignature = do getFunctionSignature(QualifiedName(None(), name)).unpack()

        while ((do advance()).tokenType != Symbol(LBrace())) { }

        with returnHandler(signature.returns);

        val (body, scope) = parseBlockExpression() match {
            case Block(i, s) => (i, s)
            case _ => unreachable(__FILE__, __LINE__)
        }
        FnDefinition(signature, body, scope)
    }

    // All top-level checks and checks for non top-level definitions are handled
    // in prepass already as well as 'module' and 'include' directives.
    var statements: List[Statement] = []

    while (not(do is_eof())) (do advance()).tokenType match {
        case Keyword(Fn()) => statements = Cons(handleFunctionDef(), statements)

        // skip these
        case Keyword(Preprocessor(_)) => { val _ = do advance() }
        case Keyword(Wrapper()) => while ((do advance()).tokenType != Symbol(RBrace())) { }
        case Keyword(Layout()) => while ((do advance()).tokenType != Symbol(RBrace())) { }
        case Keyword(Pub()) => ()
        case EOF() => ()

        //case Keyword(Let()) => handleVariableDefinition()
        case _ => do ParserError("Unexpected token '"++(do previous()).text++"', expected statement.", (do previous()).position)
    }

    AST(do getWorkingModule(), [])
}

/*
    JASL EBNF OF EXPRESSIONS

    <expression> ::= <conditional-expression>
    <conditional-expression> ::= <logical-or-expression>
    <logical-or-expression> ::= <logical-and-expression> { "||" <logical-and-expression> }
    <logical-and-expression> ::= <equality-expression> { "&&" <equality-expression> }
    <equality-expression> ::= <relational-expression> { ( "==" | "!=" ) <relational-expression> }
    <relational-expression> ::= <additive-expression> { ( ">" | "<" | ">=" | "<=" ) <additive-expression> }
    <additive-expression> ::= <multiplicative-expression> { ( "+" | "-" ) <multiplicative-expression> }
    <multiplicative-expression> ::= <unary-expression> { ( "*" | "/" ) <unary-expression> }
    <unary-expression> ::= ( "-" | "!" | "not" ) <unary-expression> | <postfix-expression>
    <postfix-expression> ::= <primary-expression> { <postfix-suffix> }
    <postfix-suffix> ::= "." <identifier> | "(" [ <arg-list> ] ")" | "::" <identifier>
    <arg-list> ::= <expression> { "," <expression> }
    <primary-expression> ::= <identifier> | <literal> | "(" <expression> ")" | <block-expression>
    <block-expression> ::= "{" { <statement> } "}"
*/
