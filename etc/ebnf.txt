File = ModuleDirective , { FunctionDefinition | LayoutDefinition | VariableDefinition | IncludeDirective } ;

Common:
    newline = "\r" | "\n" ;

    comment = "//" , { character } , newline
            | "/*" , { character } , "*/" ;

    identifier = ( "_" , ( "a".."z" | "A".."Z" ) | "a".."z" ) , { "_" | "a".."z" | "A".."Z" | "0".."9" } ;

    lvalue = identifier , { "." , identifier } ;

    custom_typename = "A".."Z" , { "a".."z" | "_" | "A".."Z" } ;
    typename = custom_typename
             | ( "i" | "u" ) , ( "32" | "8" )
             | "float" | "bool" | "void"
             | typename , "*" ;

    mutable_variable = "mut" , identifier , ":" , [ typename ] ;
    immutable_variable = identifier , ":" , [ typename ] ;
    typed_variable = [ "mut" ] , identifier , ":" , typename ;
    variable_signature = mutable_variable | immutable_variable ;

    pointer_value = /* any pointer */;
    variable = /* any defined variable */ ;

Special:
    private_field = typed_variable , ";" ;
    field = "pub" , private_field ;
    wrapper_layout_definition = [ "pub" ] , "wrapper" , "layout" , custom_typename , "{" , { private_field } , "}" ;
    normal_layout_definition = [ "pub" ] , "layout" , custom_typename , "{" , { field } , "}" ;
    layout_definition = wrapper_layout_definition | normal_layout_definition ;

    module_directive = "module" , identifier ;
    include_directive = "include" , '"' , { character } , '"' ;

    jasm_il = /* any acceptable JASM IL code */;
    character = /* any ASCII character */;
    string_applicable_character = /* any character except '"' */ ;

    referencing = variable , "." , "&" ;
    dereferencing = pointer_value , "." , "*" ;
    memory_writing = pointer_value , "." , "set" , "(" , expression , ")"
                   | "set" , "(" , ( pointer_value , "," , expression | expression_list ) , ")" ;
    offsetting = pointer_value , "." , "offset" , "(" , expression , ")"
               | "offset" , "(" , ( pointer_value , "," , expression | expression_list ) , ")" ;

Statement:
    statement = FunctionDefinition | Return | Assembly | VariableDefinition | Block | Conditional | While | ExpressionStatement | Break | Continue | Defer ;

    FunctionDefinition = [ "pub" ] , "fn" , identifier , "(" , [ typed_variable , { "," , typed_variable } ] , ")"
                         , "->" , ( "(" , [ typename , { "," , typename } ] , ")" | typename ) , Block ;

    Return = "return" , expression , ";" ;
    Assembly = "asm" , "{" , { jasm_il } , "}" ;

    VariableDefinition =
        [ "pub" ] , "let" , ( 
            mutable_variable , [ "=" , expression ]
          | immutable_variable , "=" , expression
          | "(" , mutable_variable , { "," , mutable_variable } , ")" , [ "=" , expression ]
          | "(" , immutable_variable , { "," , immutable_variable } , ")" , "=" , expression
        ) , ";" ;

    Block = "{" , { statement } , "}" ;

    Conditional = "if" , expression , Block , [ "else" , ( Block | Conditional ) ] ;

    While = "while" , expression , Block ;

    ExpressionStatement = ( FunctionCall | AssignmentExpression ) , ";" ;

    Break = "break" , ";" ;
    Continue = "continue" , ";" ;
    Defer = "defer" , FunctionCall , ";" ;

Expression:
    expression = AssignmentExpression | Initialization ;

    AssignmentExpression = lvalue , "=" , expression ;

    ConditionalExpression = LogicalOrExpression ;

    LogicalOrExpression = LogicalAndExpression , { "||" , LogicalAndExpression } ;
    LogicalAndExpression = EqualityExpression , { "&&" , EqualityExpression } ;
    EqualityExpression = ComparisonExpression , { ( "==" | "!=" ) , ComparisonExpression } ;
    ComparisonExpression = AdditiveExpression , { ( ">" | "<" | ">=" | "<=" ) , AdditiveExpression } ;
    AdditiveExpression = MultiplicativeExpression , { ( "+" | "-" ) , MultiplicativeExpression } ;
    MultiplicativeExpression = UnaryExpression , { ( "*" | "/" ) , UnaryExpression } ;
    UnaryExpression = ( "-" | "!" ) , UnaryExpression | PostfixExpression ;
    PostfixExpression = PrimaryExpression , { PostfixSuffix } ;
    PostfixSuffix = "." , identifier | "(" , [ ExpressionList ] , ")" | "::" , identifier ;
    PrimaryExpression = identifier | literal | "(" , expression , ")" | ExpressionList ;
    ExpressionList = "{" , [ expression , { "," , expression } ] , "}" ;

    literal = '"' , { string_applicable_character } , '"' 
            | integer , [ integer_suffix ]
            | integer , "." , integer
            | "nullptr" ;

    Initialization = custom_typename , "(" , expression , { "," , expression } , ")" ;
    FunctionCall = [ expression , "." ] , expression , "(" , [ expression , { "," , expression } ] , ")" ;
